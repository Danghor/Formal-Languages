 \chapter{Finite State Machines\label{chapter:finit-state-machines.tex}} 
In the previous chapter we have seen that \textsl{JFlex} is quite an amazing tool.  In this chapter
we investigate how it is possible to generate a \emph{scanner} from a regular expression.  By
answering this question we will understand how \textsl{JFlex} works.
The basic notion that we need to understand is the notion of a \emph{finite state machine},
abbreviated as \textsc{Fsm}.  There are two kinds of \textsc{Fsm}s: The deterministic ones and
non-deterministic ones.  Although non-deterministic \textsc{Fsm}s seem to be more powerful than
deterministic \textsc{Fsm}s, we will see that every non-deterministic \textsc{Fsm} can be transformed
into an equivalent deterministic \textsc{Fsm}.  After proving this result, we show how a regular
expression is translated into a non-deterministic \textsc{Fsm}.  Finally, we show that every
\textsc{Fsm} can be described by an equivalent regular expression.  Therefore, the central result of
this chapter is the equivalence of finite state machines and regular expressions.


\section{Deterministische endliche Automaten}
Die endlichen Automaten, die wir in diesem Kapitel diskutieren wollen, haben die Aufgabe,
einen String einzulesen und sollen dann entscheiden, ob dieser String ein Element der Sprache ist,
die durch den Automaten definiert wird.  Die Ausgabe dieser Automaten beschränkt sich also auf 
die beiden Werte \texttt{true} und \texttt{false}.  Der wesentliche Aspekt eines endlichen Automaten
ist, dass der Automat intern eine fest vorgegebene Anzahl von Zuständen hat, in denen er sich
befinden kann.  Die Arbeitsweise eines solchen Automaten ist dann wie folgt:
\begin{enumerate}
\item Anfangs befindet sich der Automat in einem speziellen Zustand, der als \emph{Start-Zustand}
      bezeichnet wird.
\item In jedem Verarbeitungs-Schritt liest der Automat einen Buchstaben $b$ des Eingabe-Alphabets
      $\Sigma$ und wechselt in Abhängigkeit von $b$ und dem aktuellen Zustand in den Folgezustand.
\item Eine Teilmenge aller Zustände wird als Menge der \emph{akzeptierenden Zustände} ausgezeichnet.
      Das eingelesene Wort ist genau dann ein Element der vom \textsc{EA} akzeptierten Sprache, 
      wenn sich der Automat nach dem Einlesen aller Buchstaben in einem akzeptierenden Zustand
      befindet.
\end{enumerate}

\begin{figure}[!ht]
  \centering
      \epsfig{file=Abbildungen/abstara.eps, scale=0.7}
   \caption{Ein einfacher endlicher Automat zur Erkennung der durch den
            regulären Ausdruck ``$\texttt{a}^*\cdot\texttt{b}\cdot\texttt{a}^*$''
            definierten Sprache.}
  \label{fig:abstara.dot}
\end{figure}


\noindent
Am einfachsten können endliche Automaten grafisch dargestellt werden.  Abbildung \ref{fig:abstara.dot},
zeigt einen einfachen endlichen Automaten, der die Strings erkennt, die durch den regulären Ausdruck
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{a}^*\cdot\texttt{b}\cdot\texttt{a}^*$
\\[0.2cm]
beschrieben werden.  Der Automat hat die beiden Zustände $0$ und $1$.
\begin{enumerate}
\item Zustand $0$ ist der Start-Zustand.  In der Abbildung wird das durch den Pfeil, der auf
      diesen Zustand zeigt, kenntlich gemacht.

      Wenn in diesem Zustand der Buchstabe ``\texttt{a}'' gelesen wird, dann bleibt der Automat in
      dem  Zustand $0$.  Wird hingegen der Buchstabe ``\texttt{b}'' gelesen, dann wechselt der
      Automat in den Zustand $1$. 
\item Zustand $1$ ist ein akzeptierender Zustand.  In der Abbildung ist das dadurch zu
      erkennen, dass dieser Zustand von einem doppelten Kreis umgeben ist.

      Wenn in diesem Zustand der Buchstabe ``\texttt{a}'' gelesen wird, dann bleibt der Automat in
      dem  Zustand $1$.  In der Abbildung wird nicht gezeigt, was passiert,
      wenn der Automat im Zustand $1$ den Buchstaben  ``\texttt{b}'' liest, der
      Folgezustand ist dann undefiniert. 

      Allgemein sagen wir, dass ein Automat \emph{stirbt}, wenn er in einem Zustand $q$ einen
      Buchstaben $b$ liest, für den kein Übergang definiert ist.
\end{enumerate}

\noindent
Formally, a \href{http://en.wikipedia.org/wiki/Finite-state_machine}{\emph{finite state machine}} 
is defined as a tuple.
\begin{Definition}[\textsc{Fsm}]
A \emph{finite state machine} (abbreviated as \textsc{Fsm}) is a 5-tuple 
\\[0.2cm]
\hspace*{1.3cm}
$\langle Q, \Sigma, \delta, q_0, F\rangle$
\\[0.2cm]
where the components $Q$, $\Sigma$, $\delta$, $q_0$, and $F$ satisfy the following:
\begin{enumerate}
\item $Q$ is the \underline{finite} \emph{set of states}.
\item $\Sigma$ is the \emph{input alphabet}.  Therefore, $\Sigma$ is the set of characters that can
      be used in the input strings for the given \textsc{Fsm}.
\item $\delta: Q \times \Sigma \rightarrow Q \cup \{ \Omega \}$

      is the  \emph{transition function}.  For every state $q\in Q$ and for all characters
      $c \in \Sigma$ the expression $\delta(q,c)$ computes the new state of the \textsc{Fsm}
      that is reached if the \textsc{Fsm} reads the character $c$ while in state $q$.
      If $\delta(q,c) = \Omega$, then the \textsc{Fsm} \emph{dies} when it is in state $q$ and the
      next character is $c$.
\item $q_0 \in Q$ is the \emph{start state}.
\item $F \subseteq Q$ is the set of accepting states.
      \qed
\end{enumerate}
\end{Definition}

\example
Der in Abbildung \ref{fig:abstara.dot} gezeigte endliche Automat kann formal
wie folgt beschrieben werden:
\\[0.2cm]
\hspace*{1.3cm}
$A = \langle Q, \Sigma, \delta, q_0, F\rangle$,
\\[0.2cm]
wobei gilt:
\begin{enumerate}
\item $Q = \{ 0, 1 \}$,
\item $\Sigma = \{ \texttt{a}, \texttt{b} \}$,
\item $\delta = \bigl\{ 
                        \pair(0,a) \mapsto 0, 
                        \pair(0,b) \mapsto 1, 
                        \pair(1,a) \mapsto 1, 
                        \pair(1,b) \mapsto \Omega 
                \bigr\}$,
\item $q_0 = 0$,
\item $F = \{ 1 \}$.
\end{enumerate}

Um die von einem endlichen Automaten akzeptierte Sprache formal definieren zu können, 
verallgemeinern wir die Zustands-Übergangs-Funktion $\delta$ zu einer Funktion
\\[0.2cm]
\hspace*{1.3cm}
$\delta^*: Q \times \Sigma^* \rightarrow Q \cup \{ \Omega \}$,
\\[0.2cm]
der als zweites Argument ein String übergeben werden kann.  Die Definition von
$\delta^*(q, w)$ erfolgt durch Induktion nach der Länge $|w|$ des Strings $w$.
\begin{enumerate}
\item[I.A.] $|w| = 0$: \quad  Dann gilt offenbar $w = \varepsilon$.  Wir setzen
            \\[0.2cm]
            \hspace*{1.3cm}
            $\delta^*(q, \varepsilon) := q$,
            \\[0.2cm]
            denn wenn kein Buchstabe gelesen wird, ändert der Automat seinen Zustand auch nicht.
\item[I.S.] $|w| = n + 1$: \quad In diesem Fall hat $w$ die Form $w = cv$ mit 
            $c \in \Sigma$, $v  \in \Sigma^*$ und $|v| = n$.  Wir setzen
            \\[0.2cm]
            \hspace*{1.3cm}
            $\delta^*(q, cv) := \left\{
            \begin{array}[c]{ll}              
            \delta^*\bigl(\delta(q,c),v\bigr) & \mbox{falls $\delta(q,c) \not= \Omega$;} \\
            \Omega                            & \mbox{sonst}.
            \end{array}
            \right.
            $
            \\[0.2cm]
            denn wenn der Automat das Wort $cv$ liest, wird erst der Buchstabe $c$
            gelesen.  Falls der Automat dabei in den Zustand $\delta(q,c)$ überwechselt,
            wird nun in diesem Zustand der Rest des Wortes, also $v$ gelesen.
            Falls $\delta(q,c)$ undefiniert ist, ist natürlich auch $\delta^*(q,cv)$ undefiniert.
\end{enumerate}
\begin{Definition}[akzeptierte Sprache, $L(A)$]
  Für einen endlichen Automaten $A = \langle Q, \Sigma, \delta, q_0, F\rangle$ definieren
  wir die von $A$ \textsl{akzeptierte Sprache $L(A)$} als
  \\[0.2cm]
  \hspace*{1.3cm}
  $L(A) := 
   \bigl\{ s \in \Sigma^* \mid \delta^*(q_0,s) \in F \bigr\}$. \qed
\end{Definition}
 
Die akzeptierte Sprache eines endlichen Automaten besteht also aus all den Wörtern $s$, bei denen der endliche
Automat beim Lesen des Wortes $s$ von dem Start-Zustand in einen akzeptierenden Zustand übergeht.


\exercise
Geben Sie einen EA $F$ an, so dass $L(F)$ aus genau den Wörtern der Sprache $\{a,b\}^*$ besteht, 
die den Teilstring ``\texttt{aba}'' enthalten.
\vspace*{0.3cm}


\remarkEng
There is a nice simulator for finite state machines at the following address:
\\[0.2cm]
\hspace*{1.3cm} \href{http://www.mathcs.bethel.edu/~gossett/DiscreteMathWithProof/fsme/fsme.html}{
\texttt{http://www.mathcs.bethel.edu/\symbol{126}gossett/DiscreteMathWithProof/fsme/fsme.html}}
\\[0.2cm]
This simulator is a \textsl{Java} applet, so remember to activate \textsl{Java} in your browser if
you want to try it.


\paragraph{Vollständige Endliche Automaten}
Gelegentlich ist es hilfreich, wenn ein Automat $A$ \emph{vollständig} ist: Darunter verstehen
wir einen Automaten
\\[0.2cm]
\hspace*{1.3cm}
$A = \langle Q, \Sigma, \delta, q_0, F\rangle$,
\\[0.2cm]
für den die Funktion $\delta$ nie den Wert $\Omega$ als Ergebnis liefert, es gilt also
\\[0.2cm]
\hspace*{1.3cm}
$\delta: Q \times \Sigma \rightarrow Q$.

\begin{Satz}
  Zu jedem endlichen deterministischen Automaten $A$ gibt es einen vollständigen deterministischen 
  Automaten $\hat{A}$, der dieselbe Sprache akzeptiert wie der Automat $A$, es gilt also:
  \\[0.2cm]
  \hspace*{1.3cm}
  $L(\hat{A}) = L(A)$.
\end{Satz}

\proof
Der Automat $A$ habe die Form
\\[0.2cm]
\hspace*{1.3cm}
$A = \langle Q, \Sigma, \delta, q_0, F\rangle$
\\[0.2cm]
Die Idee ist, dass wir $\hat{A}$ dadurch definieren, dass wir zu der Menge $Q$ einen neuen,
sogenannten \emph{toten} Zustand hinzufügen.  Wenn es nun für einen Zustand $q \in Q$ und einen Buchstaben $c$ keinen
Folge-Zustand in $Q$ gibt, wenn also 
\\[0.2cm]
\hspace*{1.3cm}
$\delta(q, c) = \Omega$
\\[0.2cm]
gilt, dann geht der Automat in den toten Zustand über und bleibt auch bei allen folgenden Eingaben
in diesem Zustand.

Die formale Definition von $\hat{A}$ verläuft wie folgt.
Es bezeichne $\dag$ einen \emph{neuen} Zustand, also einen Zustand, der noch nicht in 
der Zustands-Menge $Q$ vorkommt.  Wir nennen  $\dag$ auch den \emph{toten} Zustand. Dann definieren wir
\begin{enumerate}
\item $\hat{Q} := Q \cup \{ \dag \}$,

      der tote Zustand $\dag$ wird also der Menge $Q$ hinzugefügt.
\item $\hat{\delta} : \hat{Q} \times \Sigma \rightarrow \hat{Q}$,

      wobei die Werte der Funktion $\hat{\delta}$ wie folgt festgelegt werden:
      \begin{enumerate}
      \item $\delta(q,c) \not= \Omega \rightarrow \hat{\delta}(q,c) = \delta(q,c)$,

            wenn die Zustands-Übergangs-Funktion $\delta$ für den Zustand $q$ und den Buchstaben
            $c$ definiert ist und also einen Zustand als Ergebnis liefert, dann produziert
            $\hat{\delta}$ den selben Zustand.
      \item $\delta(q,c) = \Omega \rightarrow \hat{\delta}(q,c) = \dag$,

            wenn die Zustands-Übergangs-Funktion $\delta$ für den Zustand $q$ und den Buchstaben
            $c$ als Ergebnis $\Omega$ liefert und also undefiniert ist,  dann produziert
            $\hat{\delta}$ als Ergebnis den toten Zustand $\dag$.
      \item $\hat{\delta}(\dag, c) = \dag$ \quad für alle $c \in \Sigma$,

            denn aus der Unterwelt gibt es kein Entkommen: Ist der Automat einmal in dem toten
            Zustand angekommen, so kann er in keinen anderen Zustand mehr gelangen, egal
            welches Zeichen eingelesen wird.
      \end{enumerate}
\end{enumerate}
Damit können wir den Automaten $\hat{A}$ angeben:
\\[0.2cm]
\hspace*{1.3cm}
$\hat{A} = \langle \hat{Q}, \Sigma, \hat{\delta}, q_0, F \rangle$.
\\[0.2cm]
Falls nun der Automat $A$  einen String $s$ einliest und dabei nicht stirbt, so ist das 
Verhalten von $A$ und $\hat{A}$ identisch, es werden in beiden Automaten dieselben Zustände
durchlaufen.   Falls der Automat $A$ stirbt, dann geht der Automat $\hat{A}$ ersatzweise in den
Zustand $\dag$ und bleibt bei allen folgenden Eingaben in diesem Zustand.  Da der Zustand $\dag$
kein Element der Menge $F$ der akzeptierenden Zustände ist,  sind die von $A$ und $\hat{A}$
akzeptierten Sprachen identisch. \qed 

\exercise
Entwickeln Sie einen endlichen Automaten, der die durch den regulären Ausdruck
\\[0.2cm]
\hspace*{1.3cm}
$r := (\texttt{a}+\texttt{b})^* \cdot \texttt{b} \cdot (\texttt{a}+\texttt{b}) \cdot (\texttt{a}+\texttt{b})$
\\[0.2cm]
spezifizierte Sprache erkennt.

 \solution
 Der reguläre Ausdruck beschreibt genau die Wörter, die aus den Buchstaben des Alphabets 
 $\Sigma = \{ \mathtt{a}, \mathtt{b} \}$ gebildet sind, bei denen der drittletzte Buchstabe
 ein ``\texttt{b}'' ist.  Demzufolge muss der Automat in seinem Zustand den Wert der drei
 letzten Buchstaben abspeichern.  Da es für die letzten drei Buchstaben insgesamt acht
 verschiedene Kombinationsmöglichkeiten gibt, benötigen wir auch acht verschiedene
 Zustände, die wir mit den Zahlen $\{0,1,2, \cdots, 7\}$ durchnummerieren.  Im Folgenden
 beschreiben wir diese acht Zustände:
 \begin{description}
 \item[Zustand 0:] In diesem Zustand wurden als letztes die drei Buchstaben
                   ``\texttt{aaa}'' gelesen.  

                   Bei den anderen Zuständen geben wir die letzten drei in dem jeweiligen
                   Zustand gelesenen Buchstaben ohne weiteren Kommentar an.
 \item[Zustand 1:] ``\texttt{aab}''.
 \item[Zustand 2:] ``\texttt{aba}''.
 \item[Zustand 3:] ``\texttt{abb}''.
 \item[Zustand 4:] ``\texttt{bab}''.
 \item[Zustand 5:] ``\texttt{bba}''.
 \item[Zustand 6:] ``\texttt{bbb}''.
 \item[Zustand 7:] ``\texttt{baa}''.
 \end{description}
 Offensichtlich sind die Zustände 4, 5, 6 und 7 akzeptierend, denn hier ist jeweils der
 drittletzte gelesene Buchstabe ein ``\texttt{b}''.  Als nächstes überlegen wir, wie die
 Zustands-Übergangs-Funktion $\delta$ aussehen muss.  
 \begin{enumerate}
 \item[0.] Wir betrachten zunächst den Zustand 0.  Wenn die letzten drei gelesenen
           Buchstaben den Wert ``\texttt{aaa}'' haben und wir als nächstes den Buchstaben
           ``\texttt{a}'' lesen, so haben anschließend die letzten drei Buchstaben wieder
           den Wert ``\texttt{aaa}''.  Damit ist klar, dass
           \\[0.2cm]
           \hspace*{1.3cm}
           $\delta(0, \mathtt{a}) = 0$
           \\[0.2cm]
           gilt.  Lesen wir hingegen im Zustand 0 den Buchstaben ``\texttt{b}'', so sind
           die letzten drei gelesenen Buchstaben durch ``\texttt{aab}'' gegeben, was dem
           Zustand 1 entspricht.  Daher haben wir
           \\[0.2cm]
           \hspace*{1.3cm}
           $\delta(0, \mathtt{b}) = 1$.
 \item[1.] Wir betrachten nun den Zustand 1.  Wenn die letzten drei gelesenen
           Buchstaben den Wert ``\texttt{aab}'' haben und wir als nächstes den Buchstaben
           ``\texttt{a}'' lesen, so haben anschließend die letzten drei Buchstaben den
           Wert ``\texttt{aba}'', was dem Zustand 2 entspricht.  Damit ist klar, dass
           \\[0.2cm]
           \hspace*{1.3cm}
           $\delta(1, \mathtt{a}) = 2$
           \\[0.2cm]
           gilt.  Lesen wir hingegen ein ``\texttt{b}'', so haben nun die letzten drei
           Buchstaben den Wert ``\texttt{abb}'', was dem Zustand 3 entspricht.  Also gilt
           \\[0.2cm]
           \hspace*{1.3cm}
           $\delta(1, \mathtt{b}) = 3$.
 \end{enumerate}
 Die restliche Berechnung der Zustands-Übergangs-Funktion verläuft nach dem für die ersten
 beiden Zustände demonstrierten Verfahren und wird daher an dieser Stelle nicht weiter
 erläutert, das Ergebnis der Rechnung ist in Abbildung   \ref{fig:abstarbabab.dot} auf Seite
 \pageref{fig:abstarbabab.dot} gezeigt.  Wir müssen lediglich noch erklären, was der
 Start-Zustand des endlichen Automaten ist.  Zu Beginn hat der Automat noch keinen
 Buchstaben gelesen.  Das heißt insbesondere, dass die letzten drei Buchstaben alle von dem
 Buchstaben ``\texttt{b}'' verschieden sind.  Damit können wir aber den Zustand 0 als
 Start-Zustand nehmen, denn die Frage, ob wir als letztes den String ``\texttt{aaa}'' gelesen
 haben oder ob wir noch gar nichts gelesen haben ist irrelevant, wenn es nur darum geht zu
 entscheiden, ob der drittletzte gelesene Buchstabe ein ``\texttt{b}'' ist.

 \begin{figure}[!ht]
   \centering
       \epsfig{file=Abbildungen/abstarbabab.eps, scale=1.0}
    \caption{Ein endlicher Automat für den regulären Ausdruck
             ``\mbox{$(\texttt{a}+\texttt{b})^* \cdot \texttt{b} \cdot (\texttt{a}+\texttt{b}) \cdot (\texttt{a}+\texttt{b})$}''.}
   \label{fig:abstarbabab.dot}
 \end{figure}



\section{Nicht-deterministische endliche Automaten}
Die im letzten Abschnitt eingeführten deterministischen Automaten sind für manche Anwendungen zu
unhandlich, weil die Anzahl der Zustände zu groß wird.  Der in der letzten Aufgabe
zu entwickelnde Automat benötigt insgesamt 8 Zustände, denn er muss sich die letzten drei gelesenen
Zeichen merken können und dazu werden insgesamt $2^3$ Zustände benötigt.
Wir können einen solchen Automaten vereinfachen, wenn wir zulassen, dass der endliche
Automat seinen Nachfolgezustand aus einer Menge von Zuständen, die vom aktuellen Zustand und dem
gelesenen Buchstaben abhängt, frei wählen darf.  

\begin{figure}[!ht]
  \centering
      \epsfig{file=Abbildungen/abstarbabab-nd.eps, scale=0.7}
   \caption{A non-deterministic \textsc{Fsm} for the regular expression
           ``$(\texttt{a}+\texttt{b})^* \cdot \texttt{b} \cdot (\texttt{a}+\texttt{b}) \cdot (\texttt{a}+\texttt{b})$''.}
  \label{fig:fig:abstarbabab-nd.dot}
\end{figure}
\noindent
Abbildung \ref{fig:fig:abstarbabab-nd.dot} zeigt einen nicht-deterministischen endlichen Automaten, der
die durch den regulären Ausdruck
\\[0.2cm]
\hspace*{1.3cm}
$(\texttt{a}+\texttt{b})^* \cdot \texttt{b} \cdot (\texttt{a}+\texttt{b}) \cdot (\texttt{a}+\texttt{b})$
\\[0.2cm]
beschriebene Sprache akzeptiert.  Der Automat hat insgesamt 4 Zustände mit den Namen
$0$, $1$, $2$ und $3$.
\begin{enumerate}
\item $0$ ist der Start-Zustand.  Wird in diesem Zustand ein \texttt{a} gelesen,
      so bleibt der Automat im Zustand $0$.  Wird hingegen der Buchstabe \texttt{b}
      gelesen, so hat der Automat die Wahl:  Er kann entweder im Zustand $0$ bleiben,
      oder er kann in den Zustand $1$ wechseln.
\item Vom Zustand $1$ wechselt der Automat in den Zustand $2$, falls
      ein \texttt{a} oder ein \texttt{b} gelesen wurde.
\item Vom Zustand $2$ wechselt der Automat in den Zustand $3$, falls
      ein \texttt{a} oder ein \texttt{b} gelesen wurde.
\item Der Zustand $3$ ist der akzeptierende Zustand.  Von diesem Zustand gibt es keinen
      Übergang mehr.
\end{enumerate}
Der Automat aus Abbildung \ref{fig:fig:abstarbabab-nd.dot} ist nicht-deterministisch, weil er im 
Zustand $0$ bei der Eingabe von $b$ den ``richtigen'' Nachfolge-Zustand
\underline{raten} muss.   Betrachten wir eine mögliche \emph{Berechnung} des Automaten zu der
Eingabe ``\texttt{abab}'':
\\[0.2cm]
\hspace*{1.3cm}
$0 \comp{a} 0 \comp{b} 1 \comp{a} 2 \comp{b} 3$
\\[0.2cm]
Bei dieser Berechnung hat der Automat bei der Eingabe des ersten \texttt{b}'s richtig
geraten,  dass er in den Zustand $1$ wechseln muss.  Wäre der Automat hier im Zustand
$0$ verblieben, so könnte der akzeptierende Zustand $3$ nicht mehr erreicht werden:
\\[0.2cm]
\hspace*{1.3cm}
$0 \comp{a} 0 \comp{b} 0 \comp{a} 0 \comp{b} 1$
\\[0.2cm] 
Hier ist der Automat am Ende der Berechnung im Zustand $1$, der nicht akzeptierend ist.
Betrachten wir eine andere Berechnung, bei der das Wort ``\texttt{bbbbb}'' gelesen wird:
\\[0.2cm]
\hspace*{1.3cm}
$0 \comp{b} 0 \comp{b} 1 \comp{b} 2 \comp{b} 3 \comp{b} \Omega$
\\[0.2cm]
Hier ist der Automat zu früh in den Zustand $1$ gewechselt, was bei der Eingabe des
letzten Zeichens zum Tode des Automaten führt.  Wäre der Automat beim Lesen des zweiten
Buchstabens \texttt{b} noch im Zustand $0$ geblieben, so hätte er das Wort
``\texttt{bbbbb}'' erkennen können:
\\[0.2cm]
\hspace*{1.3cm}
$0 \comp{b} 0 \comp{b} 0 \comp{b} 1 \comp{b} 2 \comp{b} 3$
\\[0.2cm]
Auf den ersten Blick scheint es so zu sein, dass das Konzept der nicht-deterministischen
endlichen Automaten wesentlich mächtiger ist als das Konzept der deterministischen
endlichen Automaten, denn die nicht-deterministischen Automaten müssen ja geradezu
hellseherische Fähigkeiten haben, um den richtigen Übergang raten zu können.  Wir werden
allerdings im nächsten Abschnitt sehen, dass die beiden Konzepte bei der Erkennung von
Sprachen die gleiche Mächtigkeit haben.  Dazu formalisieren wir den Begriff des
nicht-deterministischen endlichen Automaten.  Die Definition,
die nun folgt, ist noch etwas weiter gefasst als in der informalen Erklärung, die wir
bisher gegeben haben, denn wir erlauben dem Automaten zusätzlich \emph{spontane
Übergänge}, sogenannte \emph{$\varepsilon$-Transitionen}:  Darunter verstehen wir einen
Zustands-Übergang, bei dem kein Zeichen der Eingabe gelesen wird.  Wir schreiben einen
solchen spontanen Übergäng vom Zustand $1$ in den Zustand $2$ als
\\[0.2cm]
\hspace*{1.3cm}
$1 \comp{\varepsilon} 2$.


\begin{Definition}[NEA]
Ein \emph{nicht-deterministischer endlicher Automat} (abgekürzt NEA) ist ein 5-Tupel 
\\[0.2cm]
\hspace*{1.3cm}
$\langle Q, \Sigma, \delta, q_0, F\rangle$,
\\[0.2cm]
so dass folgendes gilt:
\begin{enumerate}
\item $Q$ ist die endliche Menge von Zuständen.
\item $\Sigma$ ist das Eingabe-Alphabet.
\item $\delta$ ist eine Funktion auf $Q \times (\Sigma \cup \{ \varepsilon \})$, die jedem
      Paar $\pair(q, a)$ aus $Q \times (\Sigma \cup \{ \varepsilon \})$ eine Menge 
      $\delta(q, a) \subseteq Q$ zuordnet, es gilt also
      \\[0.2cm]
      \hspace*{1.3cm}
      $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \rightarrow 2^Q$.
      \\[0.2cm]
      Falls $a \in \Sigma$ ist, interpretieren wir $\delta(q, a)$ als die
      Menge der Zustände, in denen der Automat sein kann, wenn im Zustand $q$ das Symbol
      $a$ gelesen wurde.  Die Menge $\delta\bigl(q, \varepsilon)$ ist die
      Menge der Zustände, die der Automat aus dem Zustand $q$ mit einem
      $\varepsilon$-Übergang erreichen kann.
\item $q_0 \in Q$ ist der Start-Zustand.
\item $F \subseteq Q$ ist die Menge der akzeptierenden Zustände. 
\end{enumerate}
Falls $q_2 \in \delta(q_1, \varepsilon)$ ist, dann sagen wir, dass der Automat eine
\emph{$\varepsilon$-Transition} von dem Zustand $q_1$ in den Zustand $q_2$ hat.  Wir
schreiben dies als
\\[0.2cm]
\hspace*{1.3cm}
$q_1 \stackrel{\varepsilon}{\mapsto} q_2$.
\\[0.2cm]
Falls $c \in \Sigma$ ist und  $q_2 \in \delta(q_1, c)$ gilt, so schreiben wir
\\[0.2cm]
\hspace*{1.3cm}
$q_1 \stackrel{c}{\mapsto} q_2$. \qed
\end{Definition}

\example
Für den in Abbildung \ref{fig:fig:abstarbabab-nd.dot} auf Seite \pageref{fig:fig:abstarbabab-nd.dot} 
gezeigten nicht-deterministischen endlichen Automaten $A$ gilt
\\[0.2cm]
\hspace*{1.3cm}
$A = \langle Q, \Sigma, \delta, 0, F\rangle$ \quad mit
\begin{enumerate}
\item $Q = \{ 0, 1, 2, 3 \}$.
\item $\Sigma = \{ \texttt{a}, \texttt{b} \}$.
\item $\delta = \bigl\{ 
       \langle 0, \texttt{a}  \rangle \mapsto \{ 0 \},
       \langle 0, \texttt{b}  \rangle \mapsto \{ 0, 1 \},
       \langle 0, \varepsilon \rangle \mapsto \{ \},
       \langle 1, \texttt{a}  \rangle \mapsto \{ 2 \},
       \langle 1, \texttt{b}  \rangle \mapsto \{ 2 \},
       \langle 1, \varepsilon \rangle \mapsto \{  \}$,
      \\[0.2cm]
      \hspace*{0.74cm}
      $\langle 2, \texttt{a}  \rangle \mapsto \{ 3 \}, 
       \langle 2, \texttt{b}  \rangle \mapsto \{ 3 \}, 
       \langle 2, \varepsilon \rangle \mapsto \{ \}\bigr\}$.
      \\[0.2cm]
      Die Zustands-Übergangs-Funktion $\delta$ kann übersichtlicher auch durch die Transitionen
      \\[0.2cm]
      \hspace*{1.3cm}
       $0 \stackrel{\texttt{a}}{\mapsto} 0$, \quad
       $0 \stackrel{\texttt{b}}{\mapsto} 0$, \quad
       $0 \stackrel{\texttt{b}}{\mapsto} 1$, \quad
       $1 \stackrel{\texttt{a}}{\mapsto} 2$, \quad \\[0.1cm]
      \hspace*{1.3cm}
       $1 \stackrel{\texttt{b}}{\mapsto} 2$, \quad
       $2 \stackrel{\texttt{a}}{\mapsto} 3$ \quad und \quad
       $2 \stackrel{\texttt{b}}{\mapsto} 3$
       \\[0.2cm] 
      angegeben werden.
\item Der Start-Zustand ist $0$.
\item $F = \{ 3 \}$, der einzige akzeptierende Zustand ist also $3$. \eox
\end{enumerate}
\vspace*{0.3cm}

Wir definieren den Begriff der \emph{Konfiguration} eines NEA  als ein Paar
\\[0.2cm]
\hspace*{1.3cm}
$\pair(q, s)$
\\[0.2cm]
bestehend aus einem Zustand $q$ und $s$ einem String.  Dabei ist $q$ der Zustand, in dem der Automat
sich befindet und $s$ ist der Teil der Eingabe, der noch nicht gelesen worden ist.
Im Falle von NEA definieren wir die Relation
$\leadsto$ wie folgt:  Es gilt
\\[0.2cm]
\hspace*{1.3cm}
$\pair(q_1, cs) \leadsto \pair(q_2, s)$ \quad falls \quad $q_1 \stackrel{c}{\mapsto} q_2$,
\\[0.2cm]
es gilt also $\pair(q_1,cs) \leadsto \pair(q_2, s)$ genau dann, wenn der Automat aus dem Zustand
$q_1$ beim Lesen des Buchstabens $c$ in den Zustand $q_2$ übergehen kann.
Weiter haben wir
\\[0.2cm]
\hspace*{1.3cm}
$\langle q_1, s \rangle \leadsto \langle q_2, s \rangle$ \quad falls \quad $q_1 \stackrel{\varepsilon}{\mapsto} q_2$.
\\[0.2cm]
Hier werden die $\varepsilon$-Transitionen erfasst.  Wir bezeichnen den transitiven Abschluss der Relation $\leadsto$ mit $\leadsto^*$.
Die von einem nicht-deterministischen endlichem Automaten $A$ akzeptierte Sprache $L(A)$
ist definiert als
\\[0.2cm]
\hspace*{1.3cm}
$L(A) := \bigl\{ s \in \Sigma^* \mid 
                 \exists p \in F : \pair(q_0,s) \leadsto^* \pair(p,\varepsilon) \bigr\}$,
\\[0.2cm]
wobei $q_0$ den Start-Zustand und $F$ die Menge der akzeptierenden Zustände bezeichnet.
Ein Wort $s$ liegt also genau dann in der Sprache $L(A)$, wenn von der Konfiguration
$\langle q_0, s \rangle$ eine Konfiguration $\langle p, \varepsilon \rangle$ erreichbar
ist, bei der $p$ ein akzeptierender Zustand ist.

\example 
Für den in Abbildung \ref{fig:fig:abstarbabab-nd.dot} gezeigten endlichen Automaten $A$ besteht die akzeptierte
Sprache $L(A)$ aus allen Worten $w \in \{ \mathtt{a}, \mathtt{b} \}^*$, die mindestens die Länge drei haben und
für die der drittletzte Buchstabe ein \texttt{b} ist:
\\[0.2cm]
\hspace*{1.3cm}
$L(A) = \bigl\{ w \in \{ \mathtt{a}, \mathtt{b} \} \bigm|\; |w| \geq 3 \wedge w\bigl[|w|-2\bigr] = \mathtt{b} \bigr\}$
 \eox
\vspace*{0.3cm}

\noindent
I have found a simulator for non-deterministic finite state machines at the following address:
\\[0.2cm]
\hspace*{1.3cm}
\href{http://ivanzuzak.info/noam/webapps/fsm_simulator/}{http://ivanzuzak.info/noam/webapps/fsm\_simulator/}
\\[0.2cm]
Since this simulator is written in \textsl{JavaScript} it is even more convenient to use than the
\textsl{Java} applet for deterministic finite state machines discussed earlier.

\exercise
Geben Sie einen NEA $A$ an, so dass $L(A)$ aus genau den Wörtern der Sprache $\{a,b\}^*$ besteht, 
die den Teilstring ``\texttt{aba}'' enthalten. \eox

\section{Äquivalenz von \textsc{EA} und \textsc{NEA}}
In diesem Abschnitt zeigen wir, wie sich ein nicht-deterministischer endlicher Automat 
\\[0.2cm]
\hspace*{1.3cm}
$A = \langle Q, \Sigma, \delta, q_0, F \rangle$ 
\\[0.2cm]
so in einen deterministischen endlichen Automaten $\textsl{det}(A)$ übersetzen lässt, dass die von beiden
Automaten erkannte Sprache gleich ist, dass also 
\\[0.2cm]
\hspace*{1.3cm}
$L(A) = L\bigl(\textsl{det}(A)\bigr)$
\\[0.2cm]
gilt.  Die Idee ist, dass der Automat $\textsl{det}(A)$ die Menge aller der Zustände berechnet, in denen sich
der Automat $A$ befinden \emph{könnte}.  Die Zustände des deterministischen Automaten $\textsl{det}(A)$ sind also
\textbf{Mengen} von Zuständen des ursprünglichen nicht-deterministischen Automaten $A$.  Eine solche Menge fasst
alle die Zustände zusammen, in denen der nicht-deterministische Automat $A$ sich befinden kann.
Folglich ist eine Menge $M$ von
Zuständen des Automaten $A$ ein akzeptierender Zustand des Automaten
$\textsl{det}(A)$, wenn die Menge $M$ einen akzeptierenden Zustand des Automaten $A$
enthält.


Um diese Konstruktion von $\textsl{det}(A)$ angeben zu können, definieren wir zunächst zwei
Hilfs-Funktionen.  Wir beginnen mit dem sogenannten $\varepsilon$-Abschluss
(Englisch: $\varepsilon$-closure).  Die Funktion
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{ec}: Q \rightarrow 2^Q$
\\[0.2cm]
soll für jeden Zustand $q \in Q$ die Menge $\textsl{ec}(q)$ aller der Zustände berechnen, in die der Automat
ausgehend von dem Zustand $q$ mit Hilfe von $\varepsilon$-Transitionen übergehen kann.
Formal definieren wir die Menge $\textsl{ec}(Q)$ indem wir induktiv festlegen, welche Elemente in 
der Menge $\textsl{ec}(q)$ enthalten sind.
\begin{enumerate}
\item[I.A.:] $q \in \textsl{ec}(q)$.
\item[I.S.:] $p \in \textsl{ec}(q) \wedge r \in \delta(p, \varepsilon) \;\rightarrow\; r \in \textsl{ec}(q)$.

             Falls der Zustand $p$ ein Element des $\varepsilon$-Abschlusses 
             von $p$ ist und es eine $\varepsilon$-Transition von $p$ zu einem Zustand $r$ gibt,
             dann ist auch $r$ ein Element des $\varepsilon$-Abschlusses von $q$. 
\end{enumerate}

\begin{figure}[!ht]
  \centering
 \epsfig{file=Abbildungen/ab-or-ba-star.eps, scale=0.7}

   \caption{Nicht-deterministischer Automat mit $\varepsilon$-Transitionen.}
  \label{fig:ab-or-ba-star.dot}
\end{figure}

\example
Abbildung \ref{fig:ab-or-ba-star.dot} zeigt einen nicht-deterministischen endlichen Automaten mit
$\varepsilon$-Transitionen.  Die $\varepsilon$-Transitionen sind in der Abbildung die
Pfeile, die nicht mit einem Buchstaben beschriftet sind. Wir berechnen für alle Zustände
den $\varepsilon$-Abschluss. 
\begin{enumerate}
\item $\textsl{ec}(q_0) = \{ q_0, q_1, q_2 \}$,
\item $\textsl{ec}(q_1) = \{ q_1 \}$,
\item $\textsl{ec}(q_2) = \{ q_2 \}$,
\item $\textsl{ec}(q_3) = \{ q_3 \}$,
\item $\textsl{ec}(q_4) = \{ q_4 \}$,
\item $\textsl{ec}(q_5) = \{ q_5, q_7, q_0, q_1, q_2 \}$,
\item $\textsl{ec}(q_6) = \{ q_6, q_7, q_0, q_1, q_2 \}$,
\item $\textsl{ec}(q_7) = \{ q_7, q_0, q_1, q_2 \}$.
      \qed
\end{enumerate}

\noindent
Um den am Anfang des Abschnitts angegebenen nicht-deterministischen Automaten $A$ in einen 
deterministischen Automaten $\textsl{det}(A)$ umwandeln zu können, 
transformieren wir die Funktion $\delta$ in eine Funktion 
\\[0.2cm]
\hspace*{1.3cm}
$\delta^*: Q \times \Sigma \rightarrow 2^Q$,
\\[0.2cm]
wobei die Idee ist, dass $\delta^*(q,c)$ für einen Zustand $q$ und einen Buchstaben $c$ die Menge
aller der Zustände berechnet, in denen der Automat $A$ sich befinden kann, wenn er im Zustand $q$
zunächst den Buchstaben $c$ liest und anschließend eventuell noch einen oder auch mehrere
$\varepsilon$-Transitionen durchführt.   Formal erfolgt die Definition von $\delta^*$ durch die Formel 
\[ \delta^*(q_1,c) := 
    \bigcup \bigl\{ \textsl{ec}(q_2) \bigm| q_2 \in \delta(q_1, c) \bigr \}.
\]
Diese Formel ist wie folgt zu lesen:
\begin{enumerate}
\item Wir berechnen für alle Zustände $q_2 \in Q$, die von dem Zustand $q_1$ durch
      Lesen des Buchstabens $c$ erreicht werden können, den $\varepsilon$-Abschluss
      $\textsl{ec}(q_2)$.
\item Anschließend vereinigen wir alle diese Mengen $\textsl{ec}(q_2)$.
\end{enumerate}

\example
In Fortführung des obigen Beispiels erhalten wir beispielsweise:
\begin{enumerate}
\item $\delta^*(q_0, \texttt{a}) = \{\}$,

      denn vom Zustand $q_0$ gibt es keine Übergänge mit dem Buchstaben \texttt{a}.
      Beachten Sie, dass wir bei der oben gegebenen Definition der Funktion $\delta^*$ die 
      $\varepsilon$-Transitionen erst nach den Buchstaben-Transitionen durchgeführt werden.
\item $\delta^*(q_1, \texttt{b}) = \{q_3\}$,

      denn vom Zustand $q_1$ geht der Automat beim Lesen von \texttt{b} in den Zustand
      $q_3$ über.  Für den Zustand $q_3$ gibt es aber keine $\varepsilon$-Transitionen.
\item $\delta^*(q_3, \texttt{a}) = \{q_5, q_7, q_0, q_1, q_2\}$,

      denn vom Zustand $q_3$ geht der Automat beim Lesen von \texttt{a} zunächst in den Zustand
      $q_5$ über.  Von diesem Zustand aus sind dann die Zustände $q_7$, $q_0$, $q_1$ und $q_2$
      durch $\varepsilon$-Transitionen erreichbar. \eox
\end{enumerate}

Die Funktion $\delta^*$ überführt einen Zustand in eine Menge von Zuständen.  Da der zu entwickelnde
endliche Automat $\textsl{det}(A)$ mit \emph{Mengen von Zuständen} arbeiten wird, benötigen wir eine Funktion,
die \emph{Mengen von Zuständen} in \emph{Mengen von Zuständen} überführt.  Wir verallgemeinern daher
die Funktion $\delta^*$ zu der Funktion 
\\[0.2cm]
\hspace*{1.3cm}
$\Delta: 2^Q \times \Sigma \rightarrow 2^Q$
\\[0.2cm]
so, dass $\Delta(M, c)$ für eine Menge von Zuständen $M$ und einen Buchstaben $c$ die Menge aller
der Zustände berechnet, in denen der Automat $A$ sich befinden kann, wenn er sich zunächst in
einem Zustand aus der Menge $M$ befunden hat, dann der Buchstabe $c$ gelesen wurde und anschließend
eventuell noch $\varepsilon$-Transitionen ausgeführt werden.  Die formale Definition lautet 
\[ \Delta(M,c) := \bigcup \bigl\{ \delta^*(q,c) \bigm| q \in M \bigr\}. \]
Diese Formel ist einfach zu verstehen:  Für jeden Zustand $q \in M$ berechnen wir zunächst die Menge
aller Zustände, in denen sich der Automat nach Lesen von $c$ und eventuellen
$\varepsilon$-Transitionen befinden kann.  Die so erhaltenen Mengen vereinigen wir.

\example
In Fortführung des obigen Beispiels erhalten wir beispielsweise:
\begin{enumerate}
\item $\Delta(\{q_0, q_1, q_2\}, \texttt{a}) = \{ q_4 \}$,
\item $\Delta(\{q_0, q_1, q_2\}, \texttt{b}) = \{ q_3 \}$,
\item $\Delta(\{ q_3 \}, \texttt{a}) = \{ q_5, q_7, q_0, q_1, q_2 \}$,
\item $\Delta(\{ q_3 \}, \texttt{b}) = \{ \}$,
\item $\Delta(\{ q_4 \}, \texttt{a}) = \{ \}$,
\item $\Delta(\{ q_4 \}, \texttt{b}) = \{ q_6, q_7, q_0, q_1, q_2 \}$.
      \eox
\end{enumerate}

Wir haben nun alles Material zusammen, um den nicht-deterministischen endlichen Automaten
$A$ in einen deterministischen endlichen Automaten $\textsl{det}(A)$ überführen zu können.
Wir definieren 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{det}(A) = \bigl\langle 2^Q, \Sigma, \Delta, \textsl{ec}(q_0), \widehat{F} \bigr\rangle$.
\begin{enumerate}
\item Die Menge der Zustände von $\textsl{det}(A)$ besteht aus der Menge aller Teilmengen der Zustände von
      $A$, ist also gleich der Potenz-Menge
      $2^Q$.

      Wir werden später sehen, dass von diesen Teilmengen nicht alle wirklich benötigt werden:
      Die Teilmengen fassen ja Zustände zusammen, in denen der Automat $A$ sich 
      ausgehend von dem Start-Zustand nach der Eingabe
      eines bestimmten Wortes befinden kann.   In der Regel können nicht alle Kombinationen 
      von Zuständen auch tatsächlich erreicht werden.
\item An dem Eingabe-Alphabet ändert sich nichts, denn der neue Automat $\textsl{det}(A)$ soll ja dieselbe
      Sprache erkennen wie der Automat $A$.
\item Die oben definierte Funktion $\Delta$ gibt an, wie sich Zustands-Mengen bei Eingabe eines
      Zeichens ändern.
\item Der Start-Zustand des Automaten $\textsl{det}(A)$ ist die Menge aller der Zustände, die von dem
      Start-Zustand $q_0$ des Automaten $A$ durch $\varepsilon$-Transitionen erreichbar sind.
\item Wir definieren die Menge $\widehat{F}$ der akzeptierenden Zustände, als die Menge der
      Teilmengen von $Q$, die einen akzeptierenden Zustand enthalten, wir setzen also 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\widehat{F} := \bigl\{ M \in 2^Q \mid M \cap F \not= \{\} \bigl\}$.
\end{enumerate}

\exercise
Transformieren Sie den in Abbildung \ref{fig:fig:abstarbabab-nd.dot} auf Seite \pageref{fig:fig:abstarbabab-nd.dot} 
gezeigten nicht-deterministischen Automat $A$ in einen deterministischen Automaten
$\textsl{det}(A)$.  \eox

\solution
Wir berechnen zunächst die verschiedenen möglichen Zustands-Mengen:
\begin{enumerate}
\item Da $\textsl{ec}(0) = \{0\}$ gilt, besteht der Start-Zustand des
      deterministischen Automaten aus der Menge, die nur den Knoten $0$ enthält:
      \\[0.2cm]
      \hspace*{1.3cm}
      $S_0 := \textsl{ec}(0) = \{ 0 \}$.
      \\[0.2cm]
      Wir bezeichnen den Start-Zustand mit $S_0$.
\item Von dem Zustand $0$ geht der nicht-deterministische Automat $A$ beim Lesen von \texttt{a} in den Zustand $0$ über.
      Also gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $\Delta(S_0, \texttt{a}) = \Delta(\{0\}, \texttt{a}) = \{0\} = S_0$.
\item Von dem Zustand $0$ geht $A$ beim Lesen von \texttt{b} in den Zustand $0$ oder $1$
      über.  Also gilt
      \\[0.2cm]
      \hspace*{1.3cm}
      $S_1 := \Delta(S_0, \texttt{b}) = \Delta(\{0\}, \texttt{b}) = \{ 0, 1 \}$.
\item Wir haben $\delta(0, \texttt{a}) = \{ 0 \}$ und $\delta(1, \texttt{a}) = \{ 2 \}$.
      Daher folgt
      \\[0.2cm]
      \hspace*{1.3cm}
      $S_2 := \Delta(S_1, \texttt{a}) = \Delta(\{ 0, 1 \}, \texttt{a}) = \{ 0, 2 \}$.
\item Wir haben $\delta(0, \texttt{b}) \in \{ 0, 1 \}$ und $\delta(1, \texttt{b}) = \{ 2 \}$.
      Daher folgt
      \\[0.2cm]
      \hspace*{1.3cm}
      $S_4 := \Delta(S_1, \texttt{b}) = \Delta(\{ 0, 1 \}, \texttt{b}) = \{ 0, 1, 2 \}$
\item $S_3 := \Delta(S_2, \texttt{a}) = \Delta(\{ 0, 2 \}, \texttt{a}) = \{0, 3 \}$.
\item $S_5 := \Delta(S_2, \texttt{b}) = \Delta(\{ 0, 2 \}, \texttt{b}) = \{0, 1, 3 \}$.
\item $S_6 := \Delta(S_4, \texttt{a}) = \Delta(\{ 0, 1, 2 \}, \texttt{a}) = \{0, 2, 3 \}$.
\item $S_7 := \Delta(S_4, \texttt{b}) = \Delta(\{ 0, 1, 2 \}, \texttt{b}) = \{0, 1, 2, 3 \}$.
\item $\Delta(S_3, \texttt{a}) = \Delta(\{ 0, 3 \}, \texttt{a}) = \{0 \} = S_0$.
\item $\Delta(S_3, \texttt{b}) = \Delta(\{ 0, 3 \}, \texttt{b}) = \{ 0, 1 \} = S_1$.
\item $\Delta(S_5, \texttt{a}) = \Delta(\{ 0, 1, 3 \}, \texttt{a}) = \{ 0, 2 \} = S_2$.
\item $\Delta(S_5, \texttt{b}) = \Delta(\{ 0, 1, 3 \}, \texttt{b}) = \{ 0, 1, 2 \} = S_4$.
\item $\Delta(S_6, \texttt{a}) = \Delta(\{ 0, 2, 3 \}, \texttt{a}) = \{ 0, 3 \} = S_3$.
\item $\Delta(S_6, \texttt{b}) = \Delta(\{ 0, 2, 3 \}, \texttt{b}) = \{ 0, 1, 3 \} = S_5$.
\item $\Delta(S_7, \texttt{a}) = \Delta(\{ 0, 1, 2, 3 \}, \texttt{a}) = \{ 0, 2, 3 \} = S_6$.
\item $\Delta(S_7, \texttt{b}) = \Delta(\{ 0, 1, 2, 3 \}, \texttt{b}) = \{ 0, 1, 2, 3 \} = S_7$.
\end{enumerate}
Damit haben wir alle Zustände des deterministischen Automaten. Zur besseren Übersicht
fassen wir die Definitionen der einzelnen Zustände des deterministischen Automaten noch
einmal zusammen:
\\[0.2cm]
\hspace*{1.3cm} $S_0 = \{ 0 \}$, $S_1 = \{ 0, 1 \}$, $S_2 = \{ 0, 2 \}$, $S_3 = \{ 0, 3 \}$, $S_4 = \{ 0, 1, 2 \}$, 
\\[0.2cm]
\hspace*{1.3cm} $S_5 = \{ 0, 1, 3 \}$, $S_6 = \{ 0, 2, 3 \}$, $S_7 = \{ 0, 1, 2, 3 \}$
\\[0.2cm]
und setzen schließlich 
\\[0.2cm]
\hspace*{1.3cm}
$\widehat{Q} := \{ S_0, S_1, S_2, S_3, S_4, S_5, S_6, S_7 \}$.
\\[0.2cm]
Wir fassen die Übergangs-Funktion $\Delta$ in einer Tabelle zusammen:

\begin{center}
\begin{tabular}[t]{|l||c|c|c|c|c|c|c|c|}
\hline
$\Delta$ & $S_0$ & $S_1$ & $S_2$ & $S_3$ & $S_4$ & $S_5$ & $S_6$ & $S_7$ \\
\hline
\hline
\texttt{a} & $S_0$ & $S_2$ & $S_3$ & $S_0$ & $S_6$ & $S_2$ & $S_3$ & $S_6$ \\
\hline
\texttt{b} & $S_1$ & $S_4$ & $S_5$ & $S_1$ & $S_7$ & $S_4$ & $S_5$ & $S_7$ \\
\hline
\end{tabular}
\end{center}
Als letztes stellen wir fest, dass die Mengen $S_3$, $S_5$, $S_6$ und $S_7$ den akzeptierenden
Zustand $3$ enthalten.  Also setzen wir
\\[0.2cm]
\hspace*{1.3cm}
$\widehat{F} := \{ S_3, S_5, S_6, S_7 \}$.
\\[0.2cm]
Damit können wir nun einen deterministischen endlichen Automaten $\textsl{det}(A)$ angeben, der dieselbe 
Sprache akzeptiert wie der nicht-deterministische Automat $A$:
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{det}(A) := \langle \widehat{Q}, \Sigma, \Delta, S_0, \widehat{F}\rangle$.
\\[0.2cm]
Abbildung \ref{fig:a2.eps} zeigt den Automaten $\textsl{det}(A)$.
Wir erkennen, dass dieser Automat 8 verschiedene Zustände besitzt.  Der ursprünglich gegebene
nicht-deterministische Automat $A$ hat 4 Zustände, für die Zustands-Menge des
nicht-deterministischen Automaten gilt $Q = \{ 0, 1, 2, 3 \}$.  Die Potenz-Menge $2^Q$
besteht aus 16 Elementen.  Wieso hat dann der Automat $\textsl{det}(A)$ nur 8 und nicht $2^4 = 16$
Zustände?  Der Grund ist, dass von dem Start-Zustand $0$ nur solche Mengen von Zuständen
erreichbar sind, die den Zustand $0$ enthalten, denn egal ob \texttt{a} oder \texttt{b}
eingegeben wird, kann der Automat $A$ von $0$ immer wieder in den Zustand $0$ zurück
wechseln.  Daher muss jede Menge von Zuständen, die von $0$ erreichbar ist, selbst
wieder $0$ enthalten.  Damit entfallen als Zustände von $\textsl{det}(A)$ alle Mengen von $2^Q$, die
$0$ nicht enthalten, wodurch die Zahl der Zustände gegenüber der maximal möglichen
Anzahl halbiert wird.


\begin{figure}[!ht]
  \centering
     \vspace*{0.5cm}
      \epsfig{file=Abbildungen/a2.eps, scale=1.0}
  \caption{Der deterministische Automat $\textsl{det}(A)$.}
  \label{fig:a2.eps}
\end{figure}


\exercise
Transformieren Sie den in Abbildung \ref{fig:ab-or-ba-star.dot} auf Seite
\pageref{fig:ab-or-ba-star.dot} 
gezeigten endlichen Automaten in einen äquivalenten deterministischen endlichen
Automaten. \eox

\pagebreak

\subsection{Implementing the Conversion of NFA to DFA}
It is straightforward to implement the theory developed so far using the programming
language \href{http://wwwlehre.dhbw-stuttgart.de/~stroetma/SetlX/setlX.php}{\textsc{SetlX}}.
Figure \ref{fig:nfa2dfa.stlx} on page \pageref{fig:nfa2dfa.stlx} shows a \textsc{SetlX} program 
that converts a given non-deterministic finite
state machine (also known as \textsc{Nfa}, which is short for \underline{n}on-deterministic
\underline{f}inite \underline{a}utomaton)  into a deterministic finite state machine (also known as
\textsc{Dfa}, which is short for \underline{d}eterministic \underline{f}inite
\underline{a}utomaton).  We discuss this program line by line.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    fixpoint := procedure(s0, f) {
        result := newElements := s0;
        while (true) {
            newElements := {} +/ { f(q) : q in newElements };
            if (newElements <= result) {
                return result;
            }
            result += newElements;
        }
    };
    epsClosure := procedure(s, delta) {
        result := fixpoint({s}, q |-> delta[[q, ""]]);
        return result;
    };
    deltaStar := procedure(s, c, delta) {
        if (delta[[s, c]] != om) {
            return {} +/ { epsClosure(q, delta) : q in delta[[s, c]] };
        } else {
            return {};
        }
    };
    capitalDelta := procedure(m, c, delta) {
        return {} +/ { deltaStar(q, c, delta) : q in m };
    };
    nfa2dfa := procedure(nfa) {
        [states, sigma, delta, q0, final] := nfa;
        newStart   := epsClosure(q0, delta);
        nextStates := m |-> { capitalDelta(m, c, delta) : c in sigma };
        newStates  := fixpoint({newStart}, nextStates);
        newDelta := { [[m,c], capitalDelta(m,c,delta)] : m in newStates, c in sigma };
        newFinal := { m : m in newStates | m * final != {} };
        return [newStates, sigma, newDelta, newStart, newFinal];
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A \textsc{SetlX} program to convert an NFA into a DFA.}
\label{fig:nfa2dfa.stlx}
\end{figure}

\begin{enumerate}
\item In line 1 we define a function called \texttt{fixpoint}.  This function takes two parameters:
      \begin{enumerate}
      \item \texttt{s0} is supposed to be a set of states.
      \item \texttt{f}  is supposed to be a function that takes a state as input and returns a set
            of states as its result.
      \end{enumerate}
      The expression $\texttt{fixpoint}(\mathtt{s0},f)$ calculates a set of states $S$ such that
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{s0} \cup f(S) = S$ \quad holds, where \quad $f(S) := \bigcup\{ f(x) \mid x \in S \}$.
      \\[0.2cm]
      Hence, $\texttt{fixpoint}(\mathtt{s0},f)$ is a set $S$ such that the image of $S$ under $f$
      together with \texttt{s0} is again $S$.  The value of $S$ is computed by a so called 
      \href{http://en.wikipedia.org/wiki/Fixed-point_iteration}{\emph{fixpoint iteration}}.
      The idea is to define a sequence $(S_n)_{n \in \mathbb{N}}$ of set $S_n$ such that this
      sequence converges to the set $S$ that is sought.  The elements $S_n$ of this sequence are
      defined by induction on $n \in \mathbb{N}$.

      \begin{enumerate}
      \item Base Case: $n=0$.
        
                   $S_0$ is taken to be the first argument of the function \texttt{fixpoint},
                   i.e.~we have $S_0 := \texttt{s0}$.
      \item Induction Case: $n \mapsto n+1$.

            Define
            \\[0.2cm]
            \hspace*{1.3cm}
            $S_{n+1} := S_n \cup \bigcup \{ f(x) \mid x \in S_n \}$.
            \\[0.2cm]
            Remember that $f(x)$ is really a set of states and therefore $\{ f(x) \mid x \in S_n \}$
            is a set of set of states.  Taking the union of these sets reduces this set of sets of
            states to a mere
            set of states.  These states are combined with the states already in $S_n$.  Therefore,
            \\[0.2cm]
            \hspace*{1.3cm}
            $S_{n} \subseteq S_{n+1}$ \quad for all $n \in \mathbb{N}$.
            \\[0.2cm]
            Since the set of all states is finite, the sequence $(S_n)_{n\in\mathbb{N}}$ cannot grow indefinitely.
            Therefore, there will be a natural number $m \in \mathbb{N}$ such that 
            \\[0.2cm]
            \hspace*{1.3cm}
            $S_{m+1} = S_m$.
            \\[0.2cm]
            At this point, the sequence $(S_n)_{n \in \mathbb{N}}$ has converged. Therefore, 
            we can define $S := S_m$ and with this definition we have 
            \\[0.2cm]
            \hspace*{1.3cm}
            $f(S) \subseteq S$.
      \end{enumerate}
\item The function \texttt{epsClosure} computes the $\varepsilon$-closure of a given state
      \texttt{s}.  The transition function \texttt{delta} has to be provided as a second
      argument.  In this function we assume that \texttt{delta} is represented as a binary relation.
      For example, the transition function $\delta$ of the non-deterministic finite state
      shown in Figure \ref{fig:ab-or-ba-star.dot} can be represented in \textsc{SetlX} as the
      following binary relation:
\begin{verbatim}
    delta45 := { [ [0, "" ], {1, 2} ],
                 [ [1, "b"], {3} ],
                 [ [2, "a"], {4} ],
                 [ [3, "a"], {5} ],
                 [ [4, "b"], {6} ],
                 [ [5, "" ], {7} ],
                 [ [6, "" ], {7} ],
                 [ [7, "" ], {0} ]
               };
\end{verbatim}
      The idea of the computation is to use a fixpoint iteration that starts with the set
      $\{ \mathtt{s} \}$ and adds successively all those states that can be reached by $\varepsilon$
      transitions.  The second argument for \texttt{fixpoint} is a function that maps
      a given state $q$ into the set $\delta(q, \varepsilon)$.  Hence, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mathtt{epsilonClosure}(\mathtt{s}, \mathtt{delta}) = \textsl{ec}(\mathtt{s})$.
\item The function \texttt{deltaStar} takes a state $s$ of the non-deterministic finite
      automaton \texttt{nfa} and computes all states that can be reached from the state
      $s$ when the character $c$ is read.  This function satisfies the specification
      \\[0.2cm]
      \hspace*{1.3cm}
      $\delta^*(s,c) := 
       \bigcup \bigl\{ \textsl{ec}(q) \bigm| q \in \delta(s, c) \bigr \}$.
\item The function \texttt{capitalDelta} takes as arguments a set \texttt{m} of states
      of the deterministic automaton and a character \texttt{c} and computes
      $\Delta(m,c)$.  As the operator ``\texttt{+/}'' computes the union of all sets
      that are elements of its argument,  this function does indeed compute the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $\bigcup \bigl\{ \delta^*(q,c) \bigm| q \in m \bigr\}$.
      \\[0.2cm]
      We have to take some care as the expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{+/ \{\}}
      \\[0.2cm]
      is undefined.  The reason is that for a set $s = \{x_1, x_2, \cdots, x_n \}$ the
      value of the expression ``$\texttt{+/}\; s$'' is defined as
      \\[0.2cm]
      \hspace*{1.3cm}
      $s_1 + s_2 + \cdots + s_n$.
      \\[0.2cm]
      If the elements $s_i$ of the set $s$ are numbers, then they are added.  If they are 
      sets, the union of the sets $s_i$ is computed.  The problem is the following: If
      $s$ is empty, then we don't know whether $s$ is the empty set of numbers or whether 
      it is the empty set of sets and therefore in this case ``$\texttt{+/}\; s$'' is undefined.
      By writing ``$\{\} \;\texttt{+/}\; s$'' we insert the empty set $\{\}$ into the set $s$
      before evaluating the expression ``$\texttt{+/} s$''.  Then it is guaranteed that $s$ is
      not empty and the problem is solved.
\item The function \texttt{nfa2dfa} takes as input a non-deterministic finite automaton
      \texttt{nfa}.  It works as follows:
      \begin{enumerate}
      \item In line 26, this automaton is split up into its components.
      \item In line 27 we compute the start state of the deterministic automaton as the
            $\varepsilon$-closure of the  state $q_0$, where $q_0$ is the start state of the
            non-deterministic finite automaton.   This computation is done using the 
            function \texttt{epsilonClosure} that is defined above.
      \item Line 28 defines a function that takes a set \texttt{m} of states and transforms this
            set of states into a new set of states that results from applying the transition
            function $\Delta$ to \texttt{m} for all possible characters from $\Sigma$.  This way, we
            can compute the set of all sets of states that are reachable from the set
            \texttt{newStart}.
      \item The transition function of the deterministic finite state machine is the defined in line
            30 as a binary relation using the function \texttt{capitalDelta}
      \item The new set of final states is defined in line 31 as the set of all those sets of
            states that have a non-empty intersection with the set \texttt{f} of final states of
            the non-deterministic  automaton.
      \end{enumerate} 
\end{enumerate}

\section{Übersetzung regulärer Ausdrücke in \textsc{NEA}}
In diesem Abschnitt konstruieren wir zu einem gegebenen regulären Ausdruck $r$ einen
nicht-deterministischen endlichen Automaten $A(r)$, der die durch $r$ spezifizierte
Sprache akzeptiert:
\\[0.2cm]
\hspace*{1.3cm}
$L\bigl(A(r)\bigr) = L(r)$
\\[0.2cm]
Die Konstruktion von $A(r)$ erfolgt durch eine Induktion nach dem Aufbau des regulären
Ausdrucks $r$.  Der konstruierte Automat $A(r)$ wird die folgenden Eigenschaften
haben, die wir bei der Konstruktion komplexerer Automaten ausnutzen werden:
\begin{enumerate}
\item $A(r)$ hat keine Transition in den Start-Zustand.  
\item $A(r)$ hat genau einen akzeptierenden Zustand, den wir mit
      $\textsl{accept}\bigl(A(r)\bigr)$ bezeichnen.  Außerdem gibt es keine Übergänge, die
      von diesem akzeptierenden Zustand ausgehen.
\end{enumerate}
Im folgenden nehmen wir an, dass $\Sigma$ das Alphabet ist, das bei der
Konstruktion des regulären Ausdrucks $r$ verwendet wurde.  Dann wird $A(r)$ wie folgt definiert.
\begin{enumerate}
\item Den Automaten $A(\emptyset)$ definieren wir als
      \\[0.2cm]
      \hspace*{1.3cm}
      $A(\emptyset) = \langle \{ q_0, q_1 \}, \Sigma, \{\}, q_0, \{ q_1 \} \rangle$
      \\[0.2cm]
      Beachten Sie, dass dieser Automat keinerlei Transitionen hat.

      \begin{figure}[!ht]
        \centering
      \epsfig{file=Abbildungen/aLeer.eps, scale=0.5}
      \caption{Der Automat $A(\emptyset)$.}
      \label{fig:aLeer.eps}
      \end{figure}
      Abbildung \ref{fig:aLeer.eps} zeigt den Automaten, der die durch $\emptyset$
      spezifizierte Sprache akzeptiert.  Der Automat besteht
      nur aus dem Start-Zustand $q_0$ und dem akzeptierenden Zustand $q_1$.
      Die Funktion $\delta$ liefert für alle Argumente die leere Menge, der Automat hat
      also keinerlei Zustands-Übergänge und 
      akzeptiert daher nur die leere Sprache.  Damit gilt  $L(\emptyset) = \{\}$. 
\item Den Automaten $A(\varepsilon)$ definieren wir als
      \\[0.2cm]
      \hspace*{1.3cm}
      $A(\varepsilon) = \langle \{ q_0, q_1 \}, \Sigma, \{ \pair(q_0, \varepsilon) \mapsto q_1 \}, q_0, \{ q_1 \} \rangle$


      \begin{figure}[!ht]
        \centering
      \epsfig{file=Abbildungen/aEpsilon.eps, scale=0.5}
      \caption{Der Automat $A(\varepsilon)$.}
      \label{fig:aEpsilon.eps}
      \end{figure}
      Abbildung \ref{fig:aEpsilon.eps} zeigt den Automaten, der die durch $\varepsilon$
      spezifizierte Sprache akzeptiert.  Der Automat besteht
      nur aus dem Start-Zustand $q_0$ und dem akzeptierenden Zustand $q_1$.
      Von dem Zustand $q_0$ gibt es eine $\varepsilon$-Transition zu dem Zustand $q_1$.
      Damit akzeptiert der Automat das leere Wort und sonst nichts. 
\item Für einen Buchstaben $c \in \Sigma$ definieren wir den Automaten $A(c)$ durch
      \\[0.2cm]
      \hspace*{1.3cm}
      $A(c) = \langle \{ q_0, q_1 \}, \Sigma, 
                                \{ \langle q_0, c \rangle \mapsto q_1\}, q_0, \{ q_1 \} \rangle$

      \begin{figure}[!ht]
        \centering
      \epsfig{file=Abbildungen/aChar.eps, scale=0.5}
      \caption{Der Automat $A(c)$.}
      \label{fig:aChar.eps}
      \end{figure}
      Abbildung \ref{fig:aChar.eps} zeigt den Automaten, der die durch den Buchstaben $c$
      spezifizierte Sprache akzeptiert.  Der Automat besteht
      aus dem Start-Zustand $q_0$ und dem akzeptierenden Zustand $q_1$.
      Von dem Zustand $q_0$ gibt es eine Transition zu dem Zustand $q_1$, die beim Lesen
      des Buchstabens $c$ benutzt wird.
      Damit akzeptiert der Automat das Wort, das nur aus dem Buchstaben $c$ besteht und
      sonst nichts.
\item Um den Automaten $A(r_1 \cdot r_2)$ für die Konkatenation $r_1 \cdot r_2$ definieren
      zu können, nehmen wir zunächst an, dass die 
      Zu\-stän\-de der Automaten $A(r_1)$ und $A(r_2)$ verschieden sind.  Dies können
      wir immer erreichen, indem wir die Zustände des Automaten $A(r_2)$ umbenennen.
      Wir nehmen nun an, dass $A(r_1)$ und $A(r_2)$ die folgenden Formen haben:
      \begin{enumerate}
      \item $A(r_1) = \langle Q_1, \Sigma, \delta_1, q_1, \{ q_2 \}\rangle$,
      \item $A(r_2) = \langle Q_2, \Sigma, \delta_2, q_3, \{ q_4 \}\rangle$,
      \item $Q_1 \cap Q_2 = \{\}$.
      \end{enumerate}
      Damit können wir den endlichen Automaten $A(r_1 \cdot r_2)$ aus den beiden Automaten $A(r_1)$ und
      $A(r_2)$ zusammenbauen:  Dieser Automat ist gegeben durch
      \\[0.2cm]
      \hspace*{0.8cm}
       $\langle Q_1 \cup Q_2, \Sigma, 
                \{ \pair(q_2,\varepsilon) \mapsto q_3 \} 
                   \cup \delta_1 \cup \delta_2, q_1, \{ q_4 \} \rangle$
      \\[0.2cm]
      Die Notation $\{ \pair(q_2,\varepsilon) \mapsto q_3 \} \cup \delta_1 \cup \delta_2$
      ist so zu verstehen, dass die so spezifizierte Funktion $\delta$ alle Übergänge
      enthält, die durch die Zustands-Übergangs-Funktionen $\delta_1$ und $\delta_2$
      spezifiziert sind.  Dazu kommt dann noch der $\varepsilon$-Übergang von $q_2$ nach
      $q_3$.  Formal könnten wir daher die Funktion $\delta$ auch wie folgt spezifizieren:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\delta(q,c) := \left\{
      \begin{array}{ll}
        \{ q_3 \}       & \mbox{falls $q = q_2$ und $c = \varepsilon$}, \\[0.2cm]
        \delta_1(q, c)  & \mbox{falls $q \in Q_1$ und $\pair(q,c) \not= \pair(q_2,\varepsilon)$}, \\[0.2cm]
        \delta_2(q, c)  & \mbox{falls $q \in Q_2$.} 
      \end{array}\right.
      $
      \\[0.2cm]


      \begin{figure}[!ht]
        \centering
      \epsfig{file=Abbildungen/aConcat.eps, scale=0.8}
      \caption{Der Automat $A(r_1 \cdot r_2)$.}
      \label{fig:aConcat.eps}
      \end{figure}
      Abbildung \ref{fig:aConcat.eps} zeigt den Automaten $A(r_1 \cdot r_2)$.

      Statt der $\varepsilon$-Transition von $q_2$ nach $q_3$ können wir die beiden
      Zustände $q_2$ und $q_3$ auch identifizieren.  Das hat den Vorteil, dass der
      resultierende Automat dann etwas kleiner wird.  Bei den praktischen Übungen werden
      wir diese Zustände daher identifizieren.  Ich habe die Zustände $q_2$ und $q_3$ bei der obigen
      Darstellung nur deswegen nicht identifiziert, weil dann sowohl die grafische Darstellung als
      auch die formale Spezifikation schwieriger wird.
\item Um den Automaten $A(r_1 + r_2)$ definieren zu können, nehmen wir wieder an, dass die
      Zustände der Automaten $A(r_1)$ und $A(r_2)$ verschieden sind.  
      Wir nehmen weiter an, dass $A(r_1)$ und $A(r_2)$ die folgenden Formen haben:
      \begin{enumerate}
      \item $A(r_1) = \langle Q_1, \Sigma, \delta_1, q_1, \{ q_3 \}\rangle$,
      \item $A(r_2) = \langle Q_2, \Sigma, \delta_2, q_2, \{ q_4 \}\rangle$,
      \item $Q_1 \cap Q_2 = \{\}$.
      \end{enumerate}
      Damit können wir den Automaten $A(r_1 + r_2)$ aus den beiden Automaten $A(r_1)$ und
      $A(r_2)$ zusammenbauen:  Dieser Automat ist gegeben durch
      \\[0.2cm]
      \hspace*{0.8cm}
       $\langle \{ q_0, q_5 \} \cup Q_1 \cup Q_2, \Sigma, 
                \{ \pair(q_0,\varepsilon) \mapsto q_1, \pair(q_0,\varepsilon) \mapsto q_2,
                   \pair(q_3,\varepsilon) \mapsto q_5, \pair(q_4,\varepsilon) \mapsto q_5 \} 
                   \cup \delta_1 \cup \delta_2, q_0, \{ q_5 \} \rangle$

      \begin{figure}[!ht]
        \centering
      \epsfig{file=Abbildungen/aPlus.eps, scale=0.5}
      \caption{Der Automat $A(r_1 + r_2)$.}
      \label{fig:aPlus.eps}
      \end{figure}
      Abbildung \ref{fig:aPlus.eps} zeigt den Automaten $A(r_1 + r_2)$.
      Wir sehen, dass zusätzlich zu den Zuständen der beiden Automaten $A(r_1)$ und 
      $A(r_2)$ noch zwei weitere Zustände hinzukommen:
      \begin{enumerate}
      \item $q_0$ ist der Start-Zustand des Automaten $A(r_1 + r_2)$,
      \item $q_5$ ist der einzige akzeptierende Zustand des Automaten $A(r_1 + r_2)$.
      \end{enumerate}
      Gegenüber den Zustands-Übergängen der Automaten $A(r_1)$ und $A(r_2)$ kommen noch
      vier $\varepsilon$-Transitionen hinzu: 
      \begin{enumerate}
      \item Von dem neuen Start-Zustand $q_0$ gibt es jeweils eine
            $\varepsilon$-Transition zu den Start-Zuständen $q_1$ und $q_2$ der Automaten
             $A(r_1)$ und $A(r_2)$.
      \item Von den akzeptierenden Zuständen $q_3$ und $q_4$ der Automaten
             $A(r_1)$ und $A(r_2)$ gibt es jeweils eine $\varepsilon$-Transition zu dem
             akzeptierenden Zustand $q_5$.
      \end{enumerate}
      Um den so definierten Automaten zu vereinfachen, \emph{\textcolor{blue}{könnten}} wir einerseits die drei
      Zustände $q_0$, $q_1$ und $q_2$ und andererseits die drei Zustände 
      $q_3$, $q_4$ und $q_5$ identifizieren.  Dies werden wir aber in den Anwendungen 
      \underline{\textbf{\textcolor{red}{nicht}}} machen, weil die resultierenden Automaten dann
      schwieriger zu verstehen sind. 
\item Um den Automaten $A(r^*)$ für den Kleene-Abschluss $r^*$ 
      definieren zu können, schreiben wir $A(r)$ als
      \\[0.2cm]
      \hspace*{1.3cm}
      $A(r) = \langle Q, \Sigma, \delta, q_1, \{ q_2 \} \rangle$,
      \\[0.2cm]
      Damit können wir  $A(r^*)$ aus dem Automaten $A(r)$ 
      konstruieren:  Der Automat $A(r^*)$ ist  durch den Ausdruck
      \\[0.2cm]
      \hspace*{0.8cm}
       $\langle \{ q_0, q_3 \} \cup Q, \Sigma, 
                \{ \pair(q_0,\varepsilon) \mapsto q_1, \pair(q_2,\varepsilon) \mapsto q_1,
                   \pair(q_0,\varepsilon) \mapsto q_3, \pair(q_2,\varepsilon) \mapsto q_3 \} 
                   \cup \delta, q_0, \{ q_3 \} \rangle$
      \\[0.2cm]
      gegeben.

      \begin{figure}[!ht]
        \centering
      \epsfig{file=Abbildungen/aStar.eps, scale=0.5}
      \caption{Der Automat $A(r^*)$.}
      \label{fig:aStar.eps}
      \end{figure}
      Abbildung \ref{fig:aStar.eps} zeigt den Automaten $A(r^*)$.
      Wir sehen, dass zusätzlich zu den Zuständen des  Automaten $A(r)$ 
      noch zwei weitere Zustände hinzukommen:
      \begin{enumerate}
      \item $q_0$ ist der Start-Zustand des Automaten $A(r^*)$,
      \item $q_3$ ist der einzige akzeptierende Zustand des Automaten $A(r^*)$.
      \end{enumerate}
      Zu den Zustands-Übergängen des Automaten $A(r)$  kommen 
      vier $\varepsilon$-Transitionen hinzu: 
      \begin{enumerate}
      \item Von dem neuen Start-Zustand $q_0$ gibt es jeweils eine
            $\varepsilon$-Transition zu den Zuständen $q_1$ und $q_3$.
      \item Von $q_2$ gibt es eine  $\varepsilon$-Transition zurück zu dem
            Zustand $q_1$.
      \item Von $q_2$ gibt es eine  $\varepsilon$-Transition zu dem
            Zustand $q_3$.
      \end{enumerate}
      \textbf{\textcolor{red}{Achtung}}:  Wenn wir bei diesem Automaten versuchen würden, die Zustände
      $q_0$ und $q_1$ bzw.~$q_2$ und $q_3$ zu identifizieren, dann funktioniert das in 
      diesem Abschnitt beschriebene Verfahren in bestimmten  Fällen nicht mehr.  Diese
      Zustände \textbf{dürfen} also \underline{\textbf{\textcolor{red}{nicht}}} identifiziert werden!
\end{enumerate}

\exercise
Konstruieren Sie einen nicht-deterministischen endlichen Automaten, der die durch
den regulären Ausdruck
\\[0.2cm]
\hspace*{1.3cm}
$(\texttt{a} + \texttt{b}) \cdot \texttt{a}^* \cdot \texttt{b}$
\\[0.2cm]
spezifizierte Sprache erkennt.

\exercise
Konstruieren Sie einen nicht-deterministischen endlichen Automaten, der die durch
den regulären Ausdruck
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{a}^* \cdot \texttt{b}^*$
\\[0.2cm]
spezifizierte Sprache erkennt.  Überlegen Sie sich, warum Sie in diesem Beispiel bei der Konstruktion zur
Berechnung des Kleene-Abschlusses die Zustände, die in dem im Text beschriebenen
Algorithmus die Namen $q_0$ und $q_1$ bzw.~$q_2$ und $q_3$ haben, nicht identifizieren
dürfen.

\subsection{Implementing the Conversion of Regular Expressions into \textsc{Fsm}s}
In this section, we develop a \textsc{SetlX} program that transforms a regular expression
into a non-deterministic finite state machine.  In order to do so, we first have to decide
how to represent regular expressions.  It is convenient to represent complex regular expressions as
\emph{terms}.  In \textsc{SetlX}, a term has the form
\\[0.2cm]
\hspace*{1.3cm}
$F(t_1, \cdots, t_N)$.
\\[0.2cm]
Here, $F$ needs to be a \emph{functor}, which is just an uninterpreted function symbols.
In \textsc{SetlX}, functors have to start with a capital letter.  The arguments
 $t_1$, $\cdots$, $t_n$ can be arbitrary \textsc{SetlX} values, i.e.~the can themselves be terms, or strings,
 numbers, sets, lists, or objects.  In general, we define a function
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{rep}: \textsl{RegExp} \rightarrow \textsc{SetlX}$
\\[0.2cm]
that maps a regular expression $r$ into a term of the programming language
\textsc{SetlX}.  The idea is that for a given regular expression $r$, $\textsl{rep}(r)$ is
the \textsc{SetlX} term that represents the regular expression $r$.  
We define $\textsl{rep}(r)$ by induction on the definition of the regular
expression $r$.
\begin{enumerate}
\item $\textsl{rep}(\emptyset) := \texttt{0}$.

      The regular expression $\emptyset$ is represented as the number \texttt{0}.
\item $\textsl{rep}(\varepsilon) := \texttt{\symbol{34}\symbol{34}}$.
  
      The regular expression $\varepsilon$ is represented as the empty string.
\item $\textsl{rep}(c) := \texttt{\symbol{34}$c$\symbol{34}}$.

      A single character $c$ is represented by the string containing just this character.
\item $\textsl{rep}(r_1 \cdot r_2) := \texttt{Cat($\textsl{rep}(r_1)$, $\textsl{rep}(r_2)$)}$.
  
      The concatenation $r_1 \cdot r_2$ of two regular expressions $r_1$ and $r_2$ is
      represented by a term with the functor ``\texttt{Cat}'', while the arguments of this
      functor are the representations of the regular expressions $r_1$ and $r_2$.
\item $\textsl{rep}(r_1 + r_2) := \texttt{Or($r_1$, $r_2$)}$.

      The disjunction $r_1 + r_2$ of two regular expressions $r_1$ and $r_2$ is
      represented by a term with the functor ``\texttt{Or}''.

\item $\textsl{rep}(r^*) := \texttt{Star($\textsl{rep}(r))$}$.

      The Kleene closure $r^*$ of the  regular expression $r$ is
      represented by a term with the functor ``\texttt{Star}''.
\end{enumerate}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    class regexp2NFA(sigma) {
        this.gStateCount := -1;
        this.mSigma      := sigma;
        
        toNFA         := procedure(r)      { ... };    
        genEmptyNFA   := procedure()       { ... };
        genEpsilonNFA := procedure()       { ... };
        genCharNFA    := procedure(c)      { ... };
        catenate      := procedure(f1, f2) { ... };
        disjunction   := procedure(f1, f2) { ... };
        kleene        := procedure(f)      { ... };
        getNewState   := procedure()       { ... };
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Outline of the class \texttt{regexp2NFA}}
\label{fig:regexp-2-nfa.stlx}
\end{figure}

\noindent
We proceed to discuss the implementation of a program transforming a regular expression into a
non-deterministic finite state machine.
Figure \ref{fig:regexp-2-nfa.stlx} on page \pageref{fig:regexp-2-nfa.stlx} shows the outline of the
class \texttt{regexp2NFA} that serves as this implementation.  
\begin{enumerate}
\item The class has two member variables.
      \begin{enumerate}
      \item \texttt{gStateCount} is a counter that is used to number the states of the finites state
            machine.
      \item \texttt{mSigma} is the alphabet.
      \end{enumerate}
\item $\texttt{toNFA}(r)$ is a method that takes a regular expression $r$ and transforms this regular
      expression into a non-deterministic finite state machine that recognizes the language
      specified by $r$.
\item \texttt{genEmptyNFA} generates a non-deterministic \textsc{Fsm} that recognizes the empty language. 
\item \texttt{genEpsilonNFA} generates a non-deterministic \textsc{Fsm} that recognizes the language
      containing only the empty string. 
\item $\texttt{genCharNFA}(c)$ takes a character $c$ as argument and generates a non-deterministic \textsc{Fsm} that recognizes the
      language $L = \{ c \}$.
\item $\texttt{catenate}(f_1, f_2)$ takes two non-deterministic \textsc{Fsm}s $f_1$ and $f_2$ as arguments and
      generates a non-deterministic \textsc{Fsm} that recognizes the language $L(f_1) \cdot L(f_2)$.
      Here, $L(f_1)$ is the language recognized by $f_1$ and similarly $L(f_2)$ is the language
      recognized by $f_2$.
\item $\texttt{disjunction}(f_1, f_2)$ takes two non-deterministic \textsc{Fsm}s $f_1$ and $f_2$ as arguments and
      generates a non-deterministic \textsc{Fsm} that recognizes the language $L(f_1) \cup L(f_2)$.
\item $\texttt{kleene}(f)$ takes a non-deterministic \textsc{Fsm}s $f$ as argument and
      generates a non-deterministic \textsc{Fsm} that recognizes the language $\bigl(L(f)\bigr)^*$.
\item \texttt{getNewState} is an auxiliary function that increments the global variable \texttt{gStateCount} and returns a name
      for the corresponding state.
\end{enumerate}
We proceed to discuss the implementations of the methods of the class \texttt{regexp2NFA} in detail.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    toNFA := procedure(r) {
        match (r) {
            case 0 : return genEmptyNFA();
            case "": return genEpsilonNFA();
            case c | isString(c) && #c == 1: 
                 return genCharNFA(c);
            case Cat(r1, r2): 
                 return catenate(toNFA(r1), toNFA(r2));
            case Or(r1, r2): 
                 return disjunction(toNFA(r1), toNFA(r2));
            case Star(r0): 
                 return kleene(toNFA(r0));
            default: abort("$r$ is not a suitable regular expression");
        }
    };    
\end{Verbatim} 
\vspace*{-0.3cm}
\caption{Converting a regular expression into a non-deterministic finite state machine.}
\label{fig:regexp-2-nfa.stlx:toNFA}
\end{figure}
%\$


The implementation of the function \texttt{regexp2NFA} is shown in
Figure \ref{fig:regexp-2-nfa.stlx:toNFA} on page \pageref{fig:regexp-2-nfa.stlx:toNFA}.
The function \texttt{toNFA} takes a regular expression $r$ as its argument.  
The implementation branches in line 2 on the form of the regular
expression $r$.  Altogether, there are six different cases.  In order to understand these cases, we
need to discuss the representation of the transition function $\delta$.  In this program, we have
decided to represent the transition function $\delta$ by a binary relation \texttt{delta}.
The relation \texttt{delta} and the transition function  $\delta$ are connected via the formula
\\[0.2cm]
\hspace*{1.3cm}
$\delta(q, c) = \{ p_1, \cdots, p_k \} \;\Leftrightarrow\; \bigl[ [q,c], \{ p_1, \cdots, p_k \} \bigr] \in \mathtt{delta}$
\\[0.2cm]
which holds true for all states $q$ and all characters $c$.  Furthermore, we have
\\[0.2cm]
\hspace*{1.3cm}
$\delta(q, \varepsilon) = \{ p_1, \cdots, p_k \} \;\Leftrightarrow\; \bigl[ [q,\texttt{\symbol{34}\symbol{34}}], \{ p_1, \cdots, p_k \} \bigr] \in \mathtt{delta}$
\\[0.2cm]
for all states $q$.  However, in order to save space we do not want to store the pairs
\\[0.2cm]
\hspace*{1.3cm}
$\bigl[ [p, c], \delta(p,c) \bigr]$ \quad and \quad $\bigl[ [p, \varepsilon], \delta(p,\varepsilon) \bigr]$
\\[0.2cm]
where either $\delta(p,c)$ or $\delta(p,\varepsilon)$ is the empty set.

In order to ease the implementation we make use of the fact that all the finite
state machines shown in 
the previous section have exactly one accepting state.  Therefore, instead of representing a
non-deterministic finite state machine as a tuple of the form
\\[0.2cm]
\hspace*{1.3cm}
$\langle Q, \Sigma, \delta, q_0, F \rangle$
\\[0.2cm]
where $F$ is the set of accepting states, we instead represent a finite state machine as a tuple of
the form
\\[0.2cm]
\hspace*{1.3cm}
$\langle Q, \Sigma, \delta, q_0, q_f \rangle$
\\[0.2cm]
where $q_f$ is the single accepting state.  Then, it is straightforward to transform the finite
state machines shown in the previous section into \textsc{SetlX} code.
\begin{enumerate}
\item If $r= \texttt{0}$, then $r$ represents the regular expression  $\emptyset$.
      In this case, the function \texttt{genEmptyNFA} computes the finite state machine that
      is shown in Figure \ref{fig:aLeer.eps}.  
      
      The implementation of the function \texttt{genEmptyNFA} is shown in Figure
      \ref{fig:regexp-2-nfa.stlx:genEmptyNFA} on page \pageref{fig:regexp-2-nfa.stlx:genEmptyNFA}:
      First, we generate two new states \texttt{q0} and \texttt{q1}.  
      Finally, line 4 returns the 5-tuple
      \\[0.2cm]
      \hspace*{1.3cm}
      $\langle \{\texttt{q0}, \texttt{q1}\}, \Sigma, \{\}, \texttt{q0}, \texttt{q1} \rangle$
      \\[0.2cm]
      as the result.  This is correct, since the transition function $\delta$ has no transitions
      as can be seen in Figure \ref{fig:aLeer.eps}.  Therefore,
      \texttt{delta} is the empty  relation.



\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    genEmptyNFA := procedure(sigma) {
        q0 := getNewState();
        q1 := getNewState();
        return [ {q0, q1}, mSigma, {}, q0, q1 ];
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Generating the NFA shown in Figure \ref{fig:aLeer.eps}.}
\label{fig:regexp-2-nfa.stlx:genEmptyNFA}
\end{figure}

\item If $r = \texttt{\symbol{34}\symbol{34}}$, then $r$ represents the regular expression
      $\varepsilon$.  In this case, the function \texttt{genEpsilonNFA} computes the finite state
      machine that is shown in Figure \ref{fig:aEpsilon.eps}.

      The implementation of the function \texttt{genEpsilonNFA} is shown in Figure
      \ref{fig:regexp-2-nfa.stlx:genEpsilonNFA} on page \pageref{fig:regexp-2-nfa.stlx:genEpsilonNFA}:
      First, we generate two new states \texttt{q0} and \texttt{q1}.  The transition function
      \texttt{delta} defined in line 4 contains exactly one
      $\varepsilon$-transition from the state $\mathtt{q0}$ to the state $\mathtt{q1}$.
      

      
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    genEpsilonNFA := procedure() {
        q0 := getNewState();
        q1 := getNewState();
        delta := { [ [q0, ""], {q1} ] };
        return [ {q0, q1}, mSigma, delta, q0, q1 ];
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Generating the NFA shown in Figure \ref{fig:aEpsilon.eps}.}
\label{fig:regexp-2-nfa.stlx:genEpsilonNFA}
\end{figure}

\item If $r = \texttt{\symbol{34}}c\texttt{\symbol{34}}$, then $r$ represents a single character $c$.
      In this case, the function \texttt{genCharNFA} computes the finite state
      machine that is shown in Figure \ref{fig:aChar.eps}.

      The implementation of the function \texttt{genCharNFA} is shown in Figure
      \ref{fig:regexp-2-nfa.stlx:genCharNFA} on page \pageref{fig:regexp-2-nfa.stlx:genCharNFA}:
      After generating  two new states \texttt{q0} and \texttt{q1},   the transition function
      \texttt{delta} contains the transition from state \texttt{q0} to the state \texttt{q1} on
      reading the character $c$,



\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    genCharNFA := procedure(c) {
        q0 := getNewState();
        q1 := getNewState();
        delta := { [[q0, c], {q1}] };
        return [ {q0, q1}, mSigma, delta, q0, q1 ];
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Generating the NFA shown in Figure \ref{fig:aChar.eps}.}
\label{fig:regexp-2-nfa.stlx:genCharNFA}
\end{figure}

\item If $r = \texttt{Cat}(r_1,r_2)$, then $r$ represents the concatenation $r_1 \cdot r_2$ of the regular
      expressions $r_1$ and $r_2$. In this case,  we recursively compute two 
      finite state machines
      that recognize the strings corresponding to these regular expressions.
      These two finite state machines are then combined into a
      new finite state machine using the function \texttt{catenate}.  The function \texttt{catenate}
      works as specified in Figure \ref{fig:aConcat.eps}.

      The implementation of the function \texttt{catenate} is shown in Figure
      \ref{fig:regexp-2-nfa.stlx:catenate} on page \pageref{fig:regexp-2-nfa.stlx:catenate}:
      The function \texttt{catenate} receives two finite state machines \texttt{f1} and \texttt{f2}
      as arguments.  These finite state machines are split into their components in line 2 and line
      3.       
      The most important purpose of the function \texttt{catenate} is to construct a new transition 
      function $\delta$ such that 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\delta = \delta_1 \cup \delta_2 \cup \{ \pair(q_2, \varepsilon) \mapsto \{ q_3 \} \}$
      \\[0.2cm]
      holds.  This function is defined in lines 4.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    catenate := procedure(f1, f2) {
        [m1, sigma, delta1, q1, q2] := f1;
        [m2, _    , delta2, q3, q4] := f2;
        delta := { [[q2, ""], {q3}] } + delta1 + delta2; 
        return [ m1 + m2, mSigma, delta, q1, q4 ];
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Generating the NFA shown in Figure \ref{fig:aConcat.eps}.}
\label{fig:regexp-2-nfa.stlx:catenate}
\end{figure}

\item The remaining two cases correspond to the diagrams shown in Figure \ref{fig:aPlus.eps} and
      Figure \ref{fig:aStar.eps}.  As these cases are quite similar to the last case, there is
      no need for a detailed discussion.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    disjunction := procedure(f1, f2) {
        [m1, sigma, delta1, q1, q3] := f1;
        [m2, _    , delta2, q2, q4] := f2;
        q0 := getNewState(); 
        q5 := getNewState(); 
        delta := delta1 + delta2;
        delta += { [[q0, ""], {q1, q2}], [[q3, ""], {q5}], [[q4, ""], {q5}] };
        return [ { q0, q5 } + m1 + m2, mSigma, delta, q0, q5 ];
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Generating the NFA shown in Figure \ref{fig:aPlus.eps}.}
\label{fig:regexp-2-nfa.stlx:disjunction}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    kleene := procedure(f) {
        [m, sigma, delta0, q1, q2] := f;
        q0 := getNewState(); 
        q3 := getNewState(); 
        delta := { [[q0, ""], {q1, q3}], [[q2, ""], {q1, q3}] } + delta0;
        return [ { q0, q3 } + m, mSigma, delta, q0, q3 ];
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Generating the NFA shown in Figure \ref{fig:aStar.eps}.}
\label{fig:regexp-2-nfa.stlx:kleene}
\end{figure}
\end{enumerate}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    getNewState := procedure() {
        this.gStateCount += 1;
        return "q" + gStateCount;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Generating a new state.}
\label{fig:regexp-2-nfa.stlx:getNewState}
\end{figure}

\vspace*{\fill}
\pagebreak



\section{Übersetzung eines \textsc{EA} in einen regulären Ausdruck}
Wir runden die Theorie ab indem wir zeigen, dass sich zu jedem deterministischen endlichen
Automaten $A$ ein regulärer Ausdruck $r(A)$ angeben lässt, der dieselbe Sprache spezifiziert,
die von dem Automaten $A$ akzeptiert wird, für den also
\\[0.2cm]
\hspace*{1.3cm}
$L\bigl(r(A)\bigr) = L(A)$
\\[0.2cm]
gilt.  Der  Automat $A$ habe die Form
\\[0.2cm]
\hspace*{1.3cm}
$A = \langle \{ q_0, q_1, \cdots, q_n \}, \Sigma, \delta, q_0, F \rangle$.
\\[0.2cm]
Für jedes Paar von Zuständen $\pair(p_1,p_2) \in Q \times Q$ definieren wir einen regulären Ausdruck
$r(p_1, p_2)$.   Die Idee bei dieser Definition ist, dass der reguläre Ausdruck
$r(p_1, p_2)$ alle die Strings $w$ spezifiziert, die den Automaten $A$ von dem Zustand
$p_1$ in den Zustand $p_2$ überführen, formal gilt:
\\[0.2cm]
\hspace*{1.3cm}
$L\bigl(r(p_1, p_2)\bigr) = 
  \bigl\{ w \in \Sigma^* \mid \pair(p_1,w) \leadsto^* \pair(p_2, \varepsilon) \bigr\}$
\\[0.2cm]  
Die Definition der regulären Ausdrücke erfolgt über einen Trick: Wir definieren für
$k=0,\cdots,n+1$ reguläre Ausdrücke $r^{(k)}(p_1, p_2)$.   Diese reguläre Ausdrücke
beschreiben gerade die Strings, die den Automaten $A$ von dem Zustand
$p_1$ in den Zustand $p_2$ überführen, \underline{ohne} dass dabei zwischendurch ein
Zustand aus der Menge 
\\[0.2cm]
\hspace*{1.3cm}
$Q_k := \bigl\{ q_i \mid i \in \{k,\cdots,n \}  \bigl\} = \{ q_k, \cdots, q_n \}$ 
\\[0.2cm]
besucht wird.  Die Menge $Q_k$ enthält also nur die Zustände, deren Index größer oder
gleich $k$ ist.  Formal definieren wir dazu die dreistellige Relation 
\\[0.2cm]
\hspace*{1.3cm}
$\mapsto_k \;\subseteq\; (Q \times \Sigma^* \times Q)$.
\\[0.2cm]
Für zwei Zustände $p, q \in Q$ und einen String $w$ soll 
\\[0.2cm]
\hspace*{1.3cm}
$p \stackrel{w}{\mapsto}_k q$
\\[0.2cm]
genau dann gelten, wenn der Automat $A$ von dem Zustand $p$ beim Lesen des Wortes $w$ in
den Zustand $q$ übergeht, ohne dabei \underline{zwischendurch} in einen Zustand aus der
Menge $Q_k$ zu wechseln.  Mit ``zwischendurch'' ist hier gemeint, dass die Zustände $p$
und $q$ sehr wohl in der Menge $Q_k$ liegen können.  Die formale Definition der Relation 
$p \stackrel{w}{\mapsto}_k q$ erfolgt durch Induktion nach der Länge des Wortes $w$:
\begin{enumerate}
\item[I.A.:] $|w| \leq 1$.  Im Induktions-Anfang haben wir zwei Fälle:
  \begin{enumerate}
  \item $p \stackrel{\varepsilon}{\mapsto}_k p$,

        denn mit dem leeren Wort kann von $p$ aus nur der Zustand $p$ erreicht
        werden.
  \item $\delta(p, c) = q \;\Rightarrow\; p \stackrel{c}{\mapsto}_k q$,

        denn wenn der Automat beim Lesen des Buchstabens $c$ von dem Zustand $p$ direkt
        in den Zustand $q$ übergeht, dann werden zwischendurch keine Zustände aus $Q_k$
        besucht, denn es werden überhaupt keine Zustände zwischendurch besucht.
  \end{enumerate}
\item[I.S.:] $w = cv$ mit $|v| \geq 1$.

             \hspace*{1.3cm}
            $p \stackrel{c}{\mapsto} q \wedge q \not\in Q_k \wedge q \stackrel{v}{\mapsto}_k r
              \Rightarrow p \stackrel{cv}{\mapsto}_k r$.

             Wenn der Automat $A$ von dem Zustand $p$ durch Lesen des Buchstabens $c$
             in einen  Zustand $q \notin Q_k$ übergeht und wenn der Automat dann von
             diesem Zustand $q$ beim Lesen von $v$ in den Zustand $r$ übergehen kann, ohne
             dabei Zustände aus $Q_k$ zu benutzen, dann geht der Automat beim Lesen von
             $cv$ aus dem Zustand $p$ in den Zustand $r$ über,
             ohne zwischendurch in Zustände aus $Q_k$ zu wechseln.
\end{enumerate}
Damit können wir nun für alle $k=0,\cdots,n+1$ die regulären Ausdrücke
$r^{(k)}(p_1, p_2)$ definieren.  Wir werden diese regulären Ausdrücke so definieren, dass
hinterher
\\[0.2cm]
\hspace*{1.3cm}
$L\bigl(r^{(k)}(p_1, p_2)\bigr) = \bigl\{ w \in \Sigma^* \mid p_1 \stackrel{w}{\mapsto}_k p_2 \bigr\}$
\\[0.2cm]
gilt.
Die Definition der regulären Ausdrücke $r^{(k)}(p_1, p_2)$ erfolgt durch eine Induktion nach $k$.
\begin{enumerate}
\item[I.A.:] $k = 0$.  

  Dann gilt $Q_0 = Q$, die Menge $Q_0$ enthält also alle Zustände
  und damit dürfen wir, wenn wir vom Zustand $p_1$ in den Zustand $p_2$ übergehen,
  zwischendurch überhaupt keine Zustände besuchen.

  Wir betrachten zunächst den Fall $p_1 \not= p_2$.  Dann kann $p_1 \stackrel{w}{\mapsto}_0 p_2$ nur dann gelten, wenn $w$ aus einem
  einzigen Buchstaben besteht.   Es sei
  \\[0.2cm]
  \hspace*{1.3cm}
  $\{ c_1, \cdots, c_l \} := \{ c \in \Sigma \mid \delta(p_1,c) = p_2 \}$
  \\[0.2cm]
  die Menge aller Buchstaben, die den Zustand $p_1$ in den Zustand $p_2$ überführen.
  Falls diese Menge nicht leer ist, setzen wir 
  \\[0.2cm]
  \hspace*{1.3cm}
  $r^{(0)}(p_1, p_2) := c_1 + \cdots + c_l$. 
  \\[0.2cm]
  Ist die obige Menge leer, so gibt es keinen direkten Übergang von
  $p_1$ nach $p_2$ und wir setzen 
  \\[0.2cm]
  \hspace*{1.3cm}
  $r^{(0)}(p_1, p_2) := \emptyset$.

  Wir betrachten jetzt den Fall $p_1 = p_2$.  Definieren wir wieder
  \\[0.2cm]
  \hspace*{1.3cm}
  $\{ c_1, \cdots, c_l \} := \{ c \in \Sigma \mid \delta(p_1,c) = p_1 \}$
  \\[0.2cm]
  als die Menge aller Buchstaben, die den Zustand $p_1$ in sich selbst überführen,
  so können wir in dem Fall, dass diese Menge nicht leer ist, 
  \\[0.2cm]
  \hspace*{1.3cm}
  $r^{(0)}(p_1, p_1) := c_1 + \cdots + c_l + \varepsilon$,
  \\[0.2cm]
  setzen.  Ist die obige Menge leer, so gibt es nur den Übergang mit dem leeren Wort
  von $p_1$ nach $p_1$ und wir setzen 
  \\[0.2cm]
  \hspace*{1.3cm}
  $r^{(0)}(p_1, p_1) := \varepsilon$.
\item[I.S.:] $k \mapsto k+1$.  

  Bei dem Übergang von $r^{(k)}(p_1, p_2)$ zu  $r^{(k+1)}(p_1, p_2)$ dürfen wir zusätzlich
  den Zustand $q_k$ benutzen, denn $q_k$ ist das einzige Element der Menge $Q_k$, das
  nicht in der Menge $Q_{k+1}$ enthalten ist.  Wird ein String $w$ gelesen, der
  den Zustand $p_1$ in den Zustand $p_2$ überführt, ohne dabei zwischendurch in einen
  Zustand aus der Menge $Q_{k+1}$ zu wechseln, so gibt es zwei Möglichkeiten:
  \begin{enumerate}
  \item Es gilt bereits $p_1 \stackrel{w}{\mapsto}_k p_2$.
  \item Der String $w$ kann so in mehrere Teile $w_1 s_1\cdots s_l w_2$ aufgeteilt werden,
        dass gilt
        \begin{itemize}
        \item $p_1 \stackrel{w_1}{\mapsto}_k q_k$,

               von dem Zustand $p_1$ gelangt der Automat also beim Lesen von $w_1$
               zunächst in den Zustand $q_k$, wobei zwischendurch der Zustand
               $q_k$ nicht benutzt wird.
        \item $q_k \stackrel{s_i}{\mapsto}_k q_k$ \quad für alle $i = \{ 1, \cdots, l\}$,

              von dem Zustand $q_k$ wechselt der Automat beim Lesen der Teilstrings
              $s_i$ wieder in den Zustand $q_k$.
        \item $q_k \stackrel{w_2}{\mapsto}_k p_2$,

              schließlich wechselt der Automat von dem Zustand $q_k$ in den Zustand
              $p_2$, wobei der Rest $w_2$ gelesen wird.
        \end{itemize}
        Daher definieren wir
        \\[0.2cm]
        \hspace*{1.3cm}
        $r^{(k+1)}(p_1,p_2) := 
         r^{(k)}(p_1,p_2) + 
         r^{(k)}(p_1,q_k) \cdot \bigl(r^{(k)}(q_k,q_k)\bigr)^* \cdot r^{(k)}(q_k,p_2)$.
        \\[0.2cm]
        Dieser Ausdruck kann wie folgt gelesen werden:  Um von $p_1$ nach $p_2$ zu kommen,
        ohne dabei zwischendurch Zustände aus $Q_{k+1}$ zu benutzen, kann der Automat entweder direkt
        von $p_1$ nach $p_2$ gelangen, ohne zwischendurch Zustände aus  $Q_k$ zu benutzen, was dem Ausdruck 
        $r^{(k)}(p_1,p_2)$ entspricht, oder aber der Automat wechselt von $p_1$ ein erstes Mal
        in den Zustand $q_k$, was den Ausdruck $r^{(k)}(p_1,q_k)$ erklärt, wechselt dann beliebig oft
        von $q_k$ nach $q_k$,  was den Ausdruck  $\bigl(r^{(k)}(q_k,q_k)\bigr)^*$ erklärt und wechselt
        schließlich von $q_k$ in den Zustand $p_2$, wofür der Ausdruck $r^{(k)}(q_k,p_2)$ steht. 
  \end{enumerate}  
\end{enumerate}
Nun haben wir alles Material zusammen, um die Ausdrücke $r(p_1,p_2)$ definieren zu können.
Wir setzen 
\\[0.2cm]
\hspace*{1.3cm}
$r(p_1,p_2) := r^{(n+1)}(p_1,p_2)$. 
\\[0.2cm]
Dieser reguläre Ausdruck beschreibt die Wörter, die den Automaten von dem Zustand $p_1$ in
den Zustand $p_2$ überführen, ohne dass der Automat dabei in einen Zustand der Menge
$Q_{n+1}$ wechselt.   Nun gilt aber
\\[0.2cm]
\hspace*{1.3cm}
$Q_{n+1} = \{ q_i | i \in \{0,\cdots,n \} \wedge i \geq n+1 \} = \{\}$,
\\[0.2cm]
die Menge ist also leer!  Folglich werden durch den regulären Ausdruck $r^{(n+1)}(p_1,p_2)$
überhaupt keine Zustände ausgeschlossen:  Der Ausdruck beschreibt also genau die Strings,
die den Zustand $p_1$ in den Zustand $p_2$ überführen, es gilt also
\\[0.2cm]
\hspace*{1.3cm}
$r^{(n+1)}(p_1,p_2) = r(p_1,p_2)$.
\\[0.2cm]
Um nun einen regulären Ausdruck konstruieren zu können, der die Sprache des Automaten $A$
beschreibt, schreiben wir die Menge $F$ der akzeptierenden Zustände von $A$ als
\\[0.2cm]
\hspace*{1.3cm}
$F = \{ t_1, \cdots, t_m \}$
\\[0.2cm]
und definieren den regulären Ausdruck $r(A)$ als
\\[0.2cm]
\hspace*{1.3cm}
$r(A) := r(q_0, t_1) + \cdots + r(q_0, t_m)$
\\[0.2cm]
definieren.  Dieser Ausdruck beschreibt genau die Strings, die den Automaten $A$ aus dem Start-Zustand
in einen der akzeptierenden Zustände überführen.
\qed
\vspace*{0.3cm}


\noindent
Damit sehen wir jetzt, dass die Konzepte ``\emph{deterministischer endlicher Automat}'' und
``\emph{regulärer Ausdruck}'' äquivalent sind.
\begin{enumerate}
\item Jeder deterministische endliche Automat kann in einen äquivalenten regulären
      Ausdruck übersetzt werden.
\item Jeder reguläre Ausdruck kann in einen äquivalenten nicht-deterministischen endlichen Automaten
      transformiert werden.
\item Ein nicht-deterministischer endlicher Automat lässt sich durch die
      Teilmengen-Konstruktion in einen endlichen Automaten überführen.
\end{enumerate}

\exercise
Konstruieren Sie für den in Abbildung \ref{fig:abstara.dot} gezeigten endlichen Automaten einen
äquivalenten regulären Ausdruck.  


\solution
Der Automat hat die Zustände $0$ und $1$.  Wir berechnen zunächst die regulären Ausdrücke
$r^{(k)}(i,j)$ für alle $i,j\in\{0,1\}$ der Reihe nach für die Werte $k =0$, $1$ und $2$:
\begin{enumerate}
\item Für $k = 0$ finden wir:
      \begin{enumerate}
      \item $r^{(0)}(0, 0) = \texttt{a} + \varepsilon$,
      \item $r^{(0)}(0, 1) = \texttt{b}$,
      \item $r^{(0)}(1, 0) = \emptyset$,
      \item $r^{(0)}(1, 1) = \texttt{a} + \varepsilon$.
      \end{enumerate}
\item Für $k=1$ haben wir:
      \begin{enumerate}
      \item Für $r^{(1)}(0, 0)$ finden wir:
            \begin{eqnarray*}
                  r^{(1)}(0, 0) 
            & = & r^{(0)}(0, 0) + 
                  r^{(0)}(0, 0) \cdot \bigl(r^{(0)}(0, 0)\bigr)^* \cdot r^{(0)}(0, 0) \\
            & = & r^{(0)}(0, 0) \cdot \bigl(r^{(0)}(0, 0)\bigr)^*
            \end{eqnarray*}
             wobei wir im letzten Schritt die für reguläre Ausdrücke allgemeingültige Umformungen
             \\[0.2cm]
             \hspace*{1.3cm}
             $
             \begin{array}[t]{lcl}
               r + r \cdot r^* \cdot r & = & r \cdot (\varepsilon + r^* \cdot r) \\
                                       & = & r \cdot r^*
             \end{array}
             $
             \\[0.2cm]
             verwendet haben.
             Setzen wir für $r^{(0)}(0, 0)$ den oben gefundenen Ausdruck $\texttt{a} + \varepsilon$ ein, 
             so erhalten wir 
             \\[0.2cm]
             \hspace*{1.3cm}
             $r^{(1)}(0, 0) = (\texttt{a} + \varepsilon)\cdot (\texttt{a} + \varepsilon)^*$.
             \\[0.2cm]
             Wegen $(\texttt{a} + \varepsilon)\cdot (\texttt{a} + \varepsilon)^* = \texttt{a}^*$ haben
             wir insgesamt
             \\[0.2cm]
             \hspace*{1.3cm}
             $r^{(1)}(0, 0) = \texttt{a}^*$.
      \item Für $r^{(1)}(0, 1)$ finden wir:
            \begin{eqnarray*}
                  r^{(1)}(0, 1) 
            & = & r^{(0)}(0, 1) + 
                  r^{(0)}(0, 0) \cdot \bigl(r^{(0)}(0, 0)\bigr)^* \cdot r^{(0)}(0, 1) \\
            & = & \texttt{b} + 
                  (\texttt{a} + \varepsilon) \cdot (\texttt{a} + \varepsilon)^* \cdot \texttt{b} \\
            & = & \texttt{b} + \texttt{a}^* \cdot \texttt{b} \\
            & = & (\varepsilon + \texttt{a}^*) \cdot \texttt{b} \\
            & = & \texttt{a}^* \cdot \texttt{b} 
        \end{eqnarray*}
      \item Für $r^{(1)}(1, 0)$ finden wir:
            \begin{eqnarray*}
                  r^{(1)}(1, 0) 
            & = & r^{(0)}(1, 0) + 
                  r^{(0)}(1, 0) \cdot \bigl(r^{(0)}(0, 0)\bigr)^* \cdot r^{(0)}(0, 0) \\
            & = & \emptyset + \emptyset \cdot (\texttt{a} + \varepsilon)^* \cdot (\texttt{a} + \varepsilon) \\
            & = & \emptyset
            \end{eqnarray*}
      \item Für $r^{(1)}(1, 1)$ finden wir
            \begin{eqnarray*}
                  r^{(1)}(1, 1)
            & = & r^{(0)}(1, 1) + 
                  r^{(0)}(1, 0) \cdot \bigl(r^{(0)}(0, 0)\bigr)^* \cdot r^{(0)}(0, 1) \\
            & = & (\texttt{a} + \varepsilon) + 
                  \emptyset \cdot (\texttt{a} + \varepsilon)^* \cdot \texttt{b} \\
            & = & (\texttt{a} + \varepsilon) + \emptyset  \\
            & = & \texttt{a} + \varepsilon  
            \end{eqnarray*}
      \end{enumerate}
\item Für $k=2$ müssen wir lediglich den regulären Ausdruck $r^{(2)}(0, 1)$ berechnen.  Es gilt
            \begin{eqnarray*}
                  r^{(2)}(0, 1)
            & = & r^{(1)}(0, 1) + 
                  r^{(1)}(0, 1) \cdot \bigl(r^{(1)}(1, 1)\bigr)^* \cdot r^{(1)}(1, 1) \\
            & = & \texttt{a}^* \cdot \texttt{b} + 
                  \texttt{a}^* \cdot \texttt{b} \cdot (\texttt{a} + \varepsilon)^* \cdot (\texttt{a} + \varepsilon) \\
            & = & \texttt{a}^* \cdot \texttt{b} + \texttt{a}^* \cdot \texttt{b} \cdot \texttt{a}^* \\
            & = & \texttt{a}^* \cdot \texttt{b} \cdot (\varepsilon + \texttt{a}^*) \\
            & = & \texttt{a}^* \cdot \texttt{b} \cdot \texttt{a}^*.
        \end{eqnarray*}
\end{enumerate}
Da der Zustand 0 der Start-Zustand ist und der Zustand 1 der einzige akzeptierende Zustand
ist, können wir nun den regulären Ausdruck $r(A)$ angeben: 
\\[0.2cm]
\hspace*{1.3cm}
$r(A) = r^{(2)}(0, 1) = \texttt{a}^* \cdot \texttt{b} \cdot \texttt{a}^*$.
\\[0.2cm]
Dieses Ergebnis, das wir mühevoll abgeleitet haben, hätten wir auch durch einen einfachen
Blick auf den Automaten erhalten können, aber die oben gezeigte Rechnung formalisiert das,
was der geübte Betrachter unmittelbar erkennt und der beschriebene Algorithmus hat den
Vorteil, dass er sich implementieren lässt.
\qed

\exercise
Konstruieren Sie für den in Abbildung \ref{fig:exercise-13.eps} auf Seite
\pageref{fig:exercise-13.eps} gezeigten endlichen Automaten einen
regulären Ausdruck, der dieselbe Sprache beschreibt, die von dem abgebildeten Automaten erkannt
wird.   

\begin{figure}[!ht]
  \centering
\epsfig{file=Abbildungen/exercise-13.eps, scale=0.5}
\caption{Ein deterministischer endlicher Automat.}
\label{fig:exercise-13.eps}
\end{figure}


\subsection{Implementing the Conversion of \textsc{FSM}s into Regular Expressions}
Figure \ref{fig:dfa-2-regexp.stlx} on page \pageref{fig:dfa-2-regexp.stlx} shows how to
implement the conversion of a finite state machine  into a regular expression.  We discuss
the details of this implementation next.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    dfa2RegExp := procedure(dfa) {
        [states, sigma, delta, q0, accepting] := dfa;
        return regexpSum({ rpq(q0, p, sigma, delta, states) : p in accepting });
    };
    regexpSum := procedure(s) {
        match (s) {
            case {}:
                 return 0;
            case { r }:
                 return r;
            case { r | rs }:
                 return Or(r, regexpSum(rs));
        }
    };
    rpq := procedure(p1, p2, sigma, delta, allowed) {
        match (allowed) {
            case {}: 
                 allChars := { c : c in sigma | delta(p1, c) == p2 };
                 sum := regexpSum(allChars);
                 if (p1 == p2) {
                     if (allChars == {}) {
                         return "";
                     } else {
                         return Or("", sum);
                     }
                 } else {
                     return sum;
                 }
            case { qk | restAllowed }:
                 rkp1p2 := rpq(p1, p2, sigma, delta, restAllowed);
                 rkp1qk := rpq(p1, qk, sigma, delta, restAllowed);
                 rkqkqk := rpq(qk, qk, sigma, delta, restAllowed);
                 rkqkp2 := rpq(qk, p2, sigma, delta, restAllowed);
                 return Or(rkp1p2, Cat(Cat(rkp1qk, Star(rkqkqk)), rkqkp2));
        }    
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Converting a \textsc{Dfa} into a regular expression.}
\label{fig:dfa-2-regexp.stlx}
\end{figure}

\begin{enumerate}
\item The function \texttt{dfa2RegExp} takes a deterministic finite state machine
      \texttt{dfa} as input.  For every accepting state $p$ of the given
      \texttt{dfa}, it calculates the regular expression $r(q_0,p)$, which describes those
      strings that transform the finite state machine from the start state $q_0$ into the
      state $p$.  If $\{p_1, \cdots, p_k\}$ is the set of all accepting states of
      \texttt{dfa}, then the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $r(q_0, p_1) + \cdots + r(q_0, p_k)$
      \\[0.2cm]
      describes the language accepted by \texttt{dfa}.  This regular expression is
      computed in line 3 via the two functions \texttt{regexpSum} and \texttt{rpq}.
\item The function \texttt{regexpSum} takes as input a set $s$ of regular expressions.
      If $s$ has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      $\{ r_1, \cdots, r_k \}$,
      \\[0.2cm] 
      then the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $r_1 + \cdots + r_k$ 
      \\[0.2cm]
      is returned.  There are two special cases:
      \begin{enumerate}
      \item If $s$ is empty, then the regular expression $\emptyset$ is returned.
      \item If $s$ contains just one element, that is if $s$ has the form $s = \{r\}$, then $r$
            is returned.
      \end{enumerate}


\item The function \texttt{rpq} is called with 5 arguments:
      \begin{enumerate}
      \item The first two arguments $p_1$ and $p_2$ are states of a finite
            state machine.  The idea is that the call
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{rpq(p1, p2, sigma, delta, states)}
            \\[0.2cm]
            computes the regular expression $r(\texttt{p1}, \texttt{p2})$, which is the
            expression that describes the set of those strings $s$ that take the
            finite state machine from the state \texttt{p1} to the state \texttt{p2}.
      \item \texttt{sigma} is the alphabet of the finite state machine.
      \item \texttt{delta} is the transition function of the finite state machine.
            In this program, we have chosen to represent \texttt{delta} as a \textsc{SetlX}
            \texttt{procedure} rather than as a binary relation.
      \item \texttt{allowed} is the set of all states that are allowed as intermediate states in the
             transition of the \textsc{Fsm} from the state $p_1$ into the state $p_2$.  This set
             corresponds to the set $\{q_0, q_1, \cdots, q_n\} - Q_{k}$ in the definition of the regular
             expression $r^{(k)}(p_1, p_2)$, i.e.~the set \texttt{allowed} is the complement of the
             set $Q_k$ with respect to the set of all states.
      \end{enumerate}
      The function \texttt{rpq} is defined by recursion on its last argument.  
      \begin{enumerate}
      \item The base case of the recursion is the case where the set \texttt{allowed} is
            empty.  Then the regular expression returned by the function \texttt{rpq} must
            only specify those strings that take the \textsc{Fsm} from the state $p_1$ to the state
            $p_2$ without visiting any other state in between.  
            In line 18, the function computes the set of all characters $c$ that take the \textsc{Fsm} from
            the state $p_1$ into the state $p_2$ directly, i.e.~that satisfy
            \\[0.2cm]
            \hspace*{1.3cm}
            $\delta(p_1, c) = p_2$.
            \\[0.2cm]
            If this set is given as $\{c_1, \cdots, c_k\}$, then the variable \texttt{sum}
            gets the value
            \\[0.2cm]
            \hspace*{1.3cm}
            $c_1 + \cdots + c_k$.
            \\[0.2cm]
            Of course, if the set $\{c_1, \cdots, c_k\}$ is empty, the sum 
            $c_1 + \cdots + c_k$ has to be interpreted as the regular expression
            $\emptyset$.
            Now there are two cases:
            \begin{enumerate}
            \item $p_1 = p_2$.  In this case, the empty string $\varepsilon$ transforms
                  the state $p_1$ into $p_2$ and therefore in this case the result returned  is
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $c_1 + \cdots + c_k + \varepsilon$.
            \item $p_1 \not= p_2$.  Then the result is given as
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $c_1 + \cdots + c_k$.
            \end{enumerate}
            The function \texttt{regexpSum} is used to compute the sum $c_1 + \cdots +c_k$.  It
            takes care to return $\emptyset$ if the set $\{c_1, \cdots, c_k\}$ is empty.
      \item In the recursive case, we arbitrarily pick a state $q_k$ from the set
            \texttt{allowed} of states that may be used to move from state $p_1$ to $p_2$.
            The state is removed from the set \texttt{allowed} to produce the set \texttt{restAllowed}.
            Then, the regular expression returned has the form
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{r}(p_1,p_2) + r(p_1,q_k) \cdot \bigl(r(q_k,q_k)\bigr)^* \cdot r(q_k,p_2)$.
            \\[0.2cm]
            Here, $r(p_1,p_2)$ is computed recursively as the regular expression that
            takes the \textsc{Fsm} from the state $p_1$ to the state $p_2$ using only the states
            from the set \texttt{restAllowed}.  The regular expressions 
            $r(p_1,q_k)$, $r(q_k,q_k)$, and $r(q_k,p_2)$ are defined in a similar way.
            The reasoning for returning this result is as follows:  In order to get from
            state $p_1$ to state $p_2$, there are two possibilies:
            \begin{itemize}
            \item If we do not need to visit the state $q_k$ when transforming  the \textsc{Fsm}
                  from state $p_1$ into state $p_2$, then the regular expression
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $r(p_1,p_2)$
                  \\[0.2cm]
                  already describes the transition.
            \item If we do need to visit the state $q_k$, then we move from $p_1$ to $p_2$
                  in three steps:
                  \begin{itemize}
                  \item We move from $p_1$ to $q_k$.
                  \item Next, we can move from $q_k$ to $q_k$ as many times as we wish.
                  \item Finally, we move from $q_k$ to $p_2$.
                  \end{itemize}
                  These three steps are summarized by the regular expression
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  $r(p_1,q_k) \cdot \bigl(r(q_k,q_k)\bigr)^* \cdot r(q_k,p_2)$.
            \end{itemize}
      \end{enumerate}
\end{enumerate}


\paragraph{Historical Remark}
\href{http://en.wikipedia.org/wiki/Stephen_Cole_Kleene}{Stephen C.~Kleene} (1909 -- 1994) has shown in 1956 that the concepts of 
\emph{finite state  machines} and \emph{regular expression} have the same strength
\cite{kleene:1956}:  We have proven in this chapter that for every regular expression $r$ there is a
non-deterministic finite state machine $n$ such that $n$ recognizes the same set of strings that is
specified by $r$.  Next, we have seen that every non-deterministic finite state machine $n$ can be
transformed into a deterministic finite state machine $f$ which accepts the same language as $f$.
Finally, we have seen that given a finite state machine $f$ there is an algorithm to construct a
regular expression $r$ such that $r$ describes the language recognized by $f$.
Hence the notions of \emph{finite state machines} and \emph{regular expressions} are equivalent.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages.tex"
%%% End: 
