\chapter{Lebendigkeits-Analyse}
Bei komplexeren Funktionen ist es in der Regel nicht möglich,  für jede in der Funktion
auftretende Variable ein neues Register zu allokieren, denn dafür ist die Zahl der Register
insbesondere bei einem \textsc{Cisc}-Prozessor nicht ausreichend.  Dies ist in der Regel aber auch
nicht notwendig, denn zwei verschiedene Variablen können sich dann ein Register teilen, wenn diese
Variablen nie gleichzeitig \emph{lebendig} sind.  Dabei nennen wir eine Variable an einer bestimmten
Position lebendig, wenn auf den Wert dieser Variablen zu einem späteren Zeitpunkt noch zugegriffen
werden kann.  Betrachten wir zur Veranschaulichung die in Abbildung
\ref{fig:liveness-example-1.c} gezeigte \texttt{C}-Funktion.  In dieser Funktion werden
die vie Variablen \texttt{a}, \texttt{b}, \texttt{c} und \texttt{n} verwendet.  Es sieht
zunächst so aus, als ob vier Register notwendig wären, um alle Variablen in Registern
speichern zu können.  Wir werden zeigen, dass drei Register bereits ausreichend sind.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    int f(int n) {
        int a, b, c;
        a = 0;
        c = 0;
        do {
            b = a + 1;
            c = c + b;
            a = b * 2;
        } while (a < n);
        return c;
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine einfache \texttt{C}-Funktion.}
\label{fig:liveness-example-1.c}
\end{figure}

Wenn wir analysieren wollen, welche Variablen gleichzeitig dasselbe Register belegen
können,  müssen wir uns zunächst darüber klar werden, wann der Wert einer Variablen, der
eventuell in einem Register liegt, noch benötigt wird.  Dazu definieren wir, dass eine
Variable $v$ in einer Zeile $l$ im Programm \emph{lebendig} ist, wenn wir später noch
auf den Wert dieser Variablen zugreifen müssen.  Wir bezeichnen die Menge aller Zeilen, in denen eine
Variable $v$ lebendig ist, mit $\textsl{live}(v)$.  Diese Definition der Lebendigkeit ist zunächst noch etwas
ungenau und wird auf den folgenden Seiten präzisiert.

Zur Beantwortung der Frage, wieviele Register  zur Übersetzung des \ref{fig:liveness-example-1.c}
gezeigte Programm benötigt werden, transformieren wir dieses Programm in ein 
\emph{Assembler-ähnliches} Programm, wobei wir unter einem \emph{Assembler-ähnlichen} Programm ein
Programm verstehen wollen, dass keine komplexen Kontroll-Strukturen wie Schleifen enthält.
Das Assembler-ähnliche Programm ist in Abbildung \ref{fig:liveness-example-1-asm.c} gezeigt.  Wir
untersuchen nun, wann die einzelnen in diesem Programm benutzten Variablen lebendig sind.  Ein erster Versuch
könnte wie folgt aussehen:

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    int f(int n) {
        int a, b, c;
        a = 0;
        c = 0;
      loop:
        b = a + 1;
        c = c + b;
        a = b * 2;
        if (a < n) goto loop;
        return c;
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine einfache \texttt{C}-Funktion.}
\label{fig:liveness-example-1-asm.c}
\end{figure}


\begin{enumerate}
\item \texttt{a} wird in Zeile 6 gelesen und ist daher in dieser Zeile lebendig.  
      Da Zeile von Zeile 3 und 4 sowie auch von Zeile 8 und 9
      erreicht werden kann, ist \texttt{a} auch in diesen Zeile lebendig.  In Zeile
      7 ist \texttt{a} nicht lebendig, denn der Wert, den \texttt{a} zu diesem Zeitpunkt
      hat, wird in Zeile 8 überschrieben.  In Zeile 10 ist \texttt{a} ebenfalls nicht
      lebendig.  Insgesamt haben wir
      \[ \textsl{live}(\mathtt{a}) = \{ 3, 4, 6, 8, 9 \} \]
      \textbf{Bemerkung}:  Zeilen, die keine echten Anweisungen sondern nur Deklarationen
      enthalten, werden bei der Berechnung der Lebendigkeit einer Variablen nicht
      berücksichtigt.
      In dem obigen Beispiel sind dies die Zeilen 2 und 5.
\item \texttt{b} wird in Zeile 7 und 8 gelesen und ist daher dort lebendig.  Der Wert von
      \texttt{b} wird in Zeile 6 berechnet.  Wir könnten daher vermuten, dass 
      \[ \textsl{live}(\mathtt{b}) = \{ 6, 7, 8 \} \]
      gilt.  Wenn wir so rechnen würden, dann  würden sich die Lebendigkeits-Bereiche
      der Variablen \texttt{a} und \texttt{b} überlappen.  Tatsächlich können wir die
      Variable \texttt{a} aber in dem selben Register wie die Variable \texttt{b}
      speichern, denn \texttt{a} wird nur bei der Berechnung des Wertes \texttt{b}
      benötigt, aber sobald dieser Wert berechnet ist, ist der Wert von \texttt{a}
      irrelevant.

      Das Problem ist, dass die Frage, ob eine Variable lebendig ist, nicht an einer
      Programmzeile festgemacht werden kann, sondern an dem Übergang von einer
      Programmzeile zu einer anderen Programmzeile.  Wir schreiben daher
      \[ \textsl{live}(\mathtt{b}) = \{ 6 \ra 7,\; 7 \ra 8 \}. \]
      Damit schreibt sich $\textsl{live}(\mathtt{a})$ als
      \[ \textsl{live}(\mathtt{a}) = \{ 3 \ra 4,\; 4 \ra 6,\; 8 \ra 9,\; 9 \ra 6 \} \]
      Wir stellen nun fest, dass die Mengen $\textsl{live}(\mathtt{a})$ und
      $\textsl{live}(\mathtt{b})$ disjunkt sind, so dass wir die beiden Variablen
      tatsächlich in dem selben Register speichern können.
\item \texttt{c} wird in Zeile 7 gelesen und auch geschrieben.  Außerdem wird \texttt{c}
      auch in Zeile 10 gelesen.  Die Definition dieser Variablen ist in Zeile 4.  Daher
      haben wir
      \[ \textsl{live}(\mathtt{c})  = 
         \{ 4 \ra 6,\; 6 \ra 7,\; 7 \ra 8,\; 8 \ra 9,\; 9 \ra 6,\; 9 \ra 10 \}
      \]
      Die Argumentation für diese Gleichung ist in Detail wie folgt:
      \begin{enumerate}
      \item Da \texttt{c} in Zeile 7 gelesen wird und der Befehl 7 auf den Befehl 6 folgt, gilt
            \[ 6 \rightarrow 7 \in \textsl{live}(\mathtt{c}). \]
      \item Da \texttt{c} in Zeile 6 lebendig ist und auch nicht neu geschrieben wird,
            ist \texttt{c} auch in den Zeilen, die unmittelbar vor Zeile 6 kommen können, lebendig.
            Damit haben wir
            \[ 9 \rightarrow 6 \in \textsl{live}(\mathtt{c}) \quad \mbox{und} \quad
               4 \rightarrow 6 \in \textsl{live}(\mathtt{c}) 
            \]
      \item Da \texttt{c} in Zeile 9 lebendig ist und auch nicht neu geschrieben wird
            und da weiterhin Zeile 9 auf Zeile 8 folgt, ist \texttt{c} auch in Zeile 8 lebendig.
            Damit haben wir
            \[ 8 \rightarrow 9 \in \textsl{live}(\mathtt{c}). \]
      \item Genauso sehen wir       
            \[ 7 \rightarrow 8 \in \textsl{live}(\mathtt{c}). \]
      \end{enumerate}
\item \texttt{n} wird in Zeile 9 gelesen und in Zeile 1 definiert.  Damit finden wir
      \[ \textsl{live}(\mathtt{c})  = 
         \{ 1 \ra 3,\; 3 \ra 4,\; 4 \ra 6,\; 6 \ra 7,\; 7 \ra 8,\; 8 \ra 9,\; 9 \ra 6 \}
      \]
      Nur in Zeile 10 ist also \texttt{n} nicht mehr lebendig.
\end{enumerate}
Wir formalisieren nun die in dem obigen Beispiel durchführte Argumentation.  Wir fassen
dazu das Assembler-ähnliche Programm als einen Graphen auf.  Die Zeilen des Programms, die
später in einen Assembler-Befehl übersetzt werden, sind die Knoten des Programms. 
Zwischen zwei Zeilen $a$ und $b$ gibt es genau dann eine Kante von $a$ nach $b$, wenn bei
der Abarbeitung des Programms die Instruktion $b$ auf die Instruktion $a$ unmittelbar
folgen kann.  Den so erstellten Graph bezeichnen wir als den \emph{Kontrollfluss-Graphen}.
In dem obigen Beispiel besteht der Kontrollfluss-Graph aus den folgenden Kanten:
\[ 
  \{ 1 \ra 3,\; 3 \ra 4,\; 4 \ra 6,\; 6 \ra 7,\; 7 \ra 8,\; 8 \ra 9,\; 9 \ra 6,\; 9 \ra 10 \}.
\]
Für eine Programm-Zeile $n$ bezeichnen wir mit $\textsl{pred}(n)$ die Menge aller Knoten,
von denen eine Kante zum Knoten $n$ hin geht.  Der Funktionsname \textsl{pred} steht hier
für \emph{predecessor}.   Weiter bezeichnen wir mit $\textsl{succ}(n)$ die Menge aller
Knoten, zu denen eine Kante von $n$ aus hin führt.  Der Name \textsl{succ} steht für
\emph{successor}.  In dem obigen Beispiel gilt
\[ \textsl{pred}(6) = \{ 4, 9 \} \quad \mbox{und} \quad \textsl{succ}(9) = \{ 6, 10 \}.  \]
Weiter bezeichnen wir für eine Variable $x$ mit $\textsl{def}(x)$ die Menge aller Knoten,
in denen der Variablen ein Wert zugewiesen wird.  Beispielsweise gilt
\[ 
   \textsl{def}(\mathtt{a}) = \{ 3, 8 \} \quad \mbox{und} \quad
   \textsl{def}(\mathtt{b}) = \{ 6 \}.
\]
Schließlich bezeichnen wir für eine Variablen $x$ mit $\textsl{use}(x)$ die Menge aller
Knoten im Kontrollfluss-Graphen, in denen die Variable $x$ gelesen wird.  Beispielsweise gilt
\[ 
   \textsl{use}(\mathtt{a}) = \{ 6, 9 \} \quad \mbox{und} \quad
   \textsl{use}(\mathtt{b}) = \{ 7, 8 \}.
\]
Damit kommen wir nun zur zentralen Definition der Lebendigkeit einer Variablen.

\begin{Definition}[lebendig]
Eine Variable $x$ ist lebendig auf einer Kante $k_1 \rightarrow k_2$ im Kontrollfluss-Graphen,
falls die Kante zu einem Pfad $[k_1, k_2, \cdots, k_n]$ fortgesetzt werden kann, so dass
gilt:
\begin{enumerate}
\item $k_n \in \textsl{use}(x)$,

      die Variable $x$ wird also am Endpunk des Pfads benutzt.
\item $\{ k_2, k_2, \cdots, k_{n-1} \} \cap \textsl{def}(x) = \{\}$,

      die Variable wird also in keinem der Zwischenpunkte des Pfads neu definiert.
\end{enumerate}
\end{Definition}

\example
Die Variable \texttt{c} ist auf der Kante $7 \ra 8$ lebendig, denn diese Kante kann zu dem
Pfad $[7, 8, 9, 6, 7]$ fortgesetzt werden und auf den Punkten der Menge $\{8,9,6\}$ wird
\texttt{c} nicht neu definiert.

\begin{Definition}[\textsl{liveIn}, \textsl{liveOut}]
Für eine Variable $x$ und einen Knoten $n$ sagen wir dass $x \in \textsl{liveIn}(n)$ ist,
falls es einen Knoten $m$  gibt, so dass $x$ auf der Kante $m \ra n$ lebendig ist.
Es gilt $x \in \textsl{liveOut}(n)$ wenn es einen Knoten $k$ gibt, so dass $x$ auf der
Kante $n \ra k$ lebendig ist.
\end{Definition}

\noindent
\textbf{Bemerkung}: Anschaulich gilt $x \in \textsl{liveIn}(n)$, falls die Variable in dem
Knoten $n$ oder in einem Knoten, der im Kontrollfluss-Graphen auf $n$ folgt, gelesen wird,
ohne vorher überschrieben zu werden.  Die Bedingung $x \in \textsl{liveOut}(n)$ bedeutet,
dass der Wert von $x$ in dem Knoten $n$ (oder einem seiner Vorgänger-Knoten) definiert
wird und später noch gelesen wird, ohne vorher überschrieben zu werden.

Die Funktionen $\textsl{liveIn}()$ und $\textsl{liveOut}()$ genügen damit den folgenden
beiden Gleichungen:
\begin{enumerate}
\item $\textsl{liveIn}(n) = 
       \textsl{use}(n) \cup \bigl(\textsl{liveOut}(n) \,\backslash\, \textsl{def}(n)\bigr)$,

      in dem Knoten $n$ sind also genau die Variablen \emph{live-in}, die entweder in dem
      Knoten $n$ gelesen werden, oder aber bereits \textsl{live-out} sind und nicht in dem
      Knoten $n$ neu geschrieben werden.
\item $\textsl{liveOut}(n) =
       \bigcup\limits_{k \in \textsl{succ}(n)} \textsl{liveIn}(k)$,

      in dem Knoten $n$ sind genau die Variablen \emph{live-out}, die in einem der
      Nachfolgerknoten \emph{live-in} sind.
\end{enumerate}
Über diese Gleichungen können nun die Funktionen $\textsl{liveIn}()$ und
$\textsl{liveOut}()$ iterativ berechnet werden.   Abbildung \ref{fig:live-loop} zeigt
den Pseudo-Code.  Zunächst werden  $\textsl{liveIn}(n)$ und
$\textsl{liveOut}(n)$ für jeden Knoten $n$ mit der leeren Menge initialsiert.
Die \texttt{while}-Schleife in Zeile 5 wird solange iteriert, bis sich
die Mengen $\textsl{liveIn}(n)$ und $\textsl{liveOut}(n)$ nicht mehr ändern.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}\(\)
                ]
    for (k in Nodes) \{
        liveIn(k)  := \{\};
        liveOut(k) := \{\};
    \}
    while (change) \{
        for (n in Nodes) \{
            liveIn(n)  := use(n) \(\cup\) (liveOut(n) - def(n));
            liveOut(n) := \(\bigcup\) \{ liveIn(k) | k \(\in\) succ(n) \};
        \}
    \}
\end{Verbatim} 
\vspace*{-0.3cm}
\caption{Pseudo-Code zur Berechnung von $\textsl{liveIn}(n)$ und $\textsl{liveOut}(n)$}
\label{fig:live-loop}
\end{figure}

\noindent
Die Berechnung der Funktion $\textsl{live}(x)$ für eine Kante $k \ra n$ ergibt sich nun
nach der folgenden Formel
\[ 
   (k \ra n) \in \textsl{live}(x) \quad \mbox{g.d.w.} \quad
   n \in \textsl{liveIn}(x) \wedge k \in \textsl{pred}(n).
\]
Die Variable $x$ ist also auf der Kante $k \ra n$ genau dann lebendig, wenn $x$ eine
Element der Menge $\textsl{liveIn}(n)$ ist und wenn außerdem die Kante $k \ra n$ eine
Kante des Kontrollfluss-Graphen ist.  


Ist die Funktion $\textsl{live}(x)$ für alle Variablen berechnet, so definieren wir, dass
zwei Variablen $x$ und $y$ \emph{im Konflikt} miteinander stehen, wenn 
\[ \textsl{live}(x) \cap \textsl{live}(y) \not= \{\}.  \]
gilt.  In diesem Fall benötigen wir verschiedene Register für die Variablen $x$ und $y$.
Ist die Schnittmenge $\textsl{live}(x) \cap \textsl{live}(y)$ hingegen leer, so können wir
die Variablen $x$ und $y$ im selben Register speichern.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formale-sprachen"
%%% End: 
