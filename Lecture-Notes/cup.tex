\chapter{Der Parser-Generator \textsc{Cup} \label{chapter:cup}}
LALR-Parser erlauben es, die Grammatiken vieler Programmiersprachen in natürlicher Weise
zu parsen.  Da die meisten von Ihnen in der Praxis vermutlich mit \textsl{Java} arbeiten, 
möchte ich Ihnen in diesem Kapitel einen LALR-Parser-Generator vorstellen, der einen Parser für die
Programmiersprache \textsl{Java} erzeugt.  Dieses Kapitel gibt daher eine
Einführung in die Verwendung des Parser-Generators \textsc{Cup} \cite{hudson:1999}, der auch
unter dem Namen \textsl{JavaCup} bekannt ist.
\textsc{Cup} selber ist nur ein Parser-Generator.  Da wir
zusätzlich einen Scanner benötigen, werden wir diesen in unseren Beispielen von \textsl{JFlex}
erzeugen lassen.  Wir werden die Version 0.11b des Parser-Generators \textsc{Cup} 
verwenden.  Sie finden diese Version im Netz unter 
\\[0.2cm]
\hspace*{1.3cm}
\href{http://www2.cs.tum.edu/projects/cup/}{\texttt{http://www2.cs.tum.edu/projects/cup/}}.
\\[0.2cm]
Sie finden dort eine komprimierte ``\texttt{.tar}''-Datei, in der sich zwei
``\texttt{.jar}''-Dateien befinden.
\begin{enumerate}
\item Die Datei \texttt{java-cup-11b.jar} beinhaltet das ausführbare Programm.
\item Die Datei \texttt{java-cup-11b-runtime.jar} enthält die Klassen, die Sie beim Übersetzen des
      von \textsc{Cup} erzeugten Parsers benötigen.
\end{enumerate}

\section{Spezifikation einer Grammatik für  \textsc{Cup}}
Eine \textsc{Cup}-Spezifikation besteht aus vier Teilen.
\begin{enumerate}
\item Der erste Teil enthält eine (optionale) Paket-Deklaration sowie die benötigten
      Import-Deklarationen.  Außerdem können wir hier den Namen der Klasse spezifizieren, die den
      von \textsc{Cup} erzeugten Parser enthält.
\item Der zweite Teil deklariert die verwendeten Symbole.  Hier werden also die Terminale
      und die syntaktischen Variablen spezifiziert.
\item Der dritte Teil ist wieder optional und spezifiziert die Präzedenzen und Assoziativitäten 
      der verwendeten Operator-Symbolen.
\item Der vierte Teil enthält die Grammatik-Regeln.
\end{enumerate}
Abbildung \ref{fig:calc.cup} auf Seite \pageref{fig:calc.cup} zeigt eine \textsl{Cup}-Spezifikation,
mit deren Hilfe arithmetische Ausdrücke ausgewertet werden können.  In dieser
\textsl{Cup}-Spezifikation sind die Schlüsselwörter unterstrichen.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    import java_cup.runtime.*;
    \underline{class} ExprParser;
    
    \underline{terminal}            SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD;
    \underline{terminal}            LPAREN, RPAREN;
    \underline{terminal} Integer    NUMBER;
    
    \underline{nonterminal}         expr_list, expr_part;
    \underline{nonterminal} Integer expr, prod, fact;
    
    \underline{start} \underline{with} expr_list;

    expr_list ::= expr_list expr_part 
               |  expr_part
               ;
    
    expr_part ::= expr:e \{: System.out.println("result = " + e); :\} SEMI 
               ;
    
    expr ::= expr:e PLUS  prod:p \{: \underline{RESULT} = e + p; :\} 
          |  expr:e MINUS prod:p \{: \underline{RESULT} = e - p; :\} 
          |  prod:p              \{: \underline{RESULT} = p;     :\}
          ;
    
    prod ::= prod:p TIMES  fact:f \{: \underline{RESULT} = p * f; :\}
          |  prod:p DIVIDE fact:f \{: \underline{RESULT} = p / f; :\} 
          |  prod:p MOD    fact:f \{: \underline{RESULT} = p % f; :\} 
          |  fact:f               \{: \underline{RESULT} = f;     :\}
          ;
    
    fact ::= LPAREN expr:e RPAREN \{: \underline{RESULT} = e;   :\} 
          |  MINUS  fact:e        \{: \underline{RESULT} = - e; :\} 
          |  NUMBER:n             \{: \underline{RESULT} = n;   :\} 
          ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\textsc{Cup}-Spezifikation eines Parsers für arithmetische Ausdrücke}
\label{fig:calc.cup}
\end{figure}

\begin{enumerate}
\item Die gezeigte \textsc{Cup}-Spezifikation enthält keine Paket-Deklarationen.
\item Die Spezifikation beginnt in Zeile 1 mit dem Import der Klassen von
      \texttt{java\_cup.runtime}.  Dieses Paket muss immer importiert werden, denn dort wird
      beispielsweise die Klasse \texttt{Symbol} 
      definiert, die wir auch später noch in dem in Abbildung \ref{fig:calc.jflex} gezeigten Scanner
      verwenden werden.

      Würden noch weitere Pakete benötigt, so könnten diese hier ebenfalls importiert werden.
\item In Zeile 2 spezifizieren wir, dass die erzeugte Parser-Klasse den Namen \texttt{ExprParser}
      haben soll.
\item In den Zeilen 4 bis 6 werden die Terminale deklariert.  Es gibt zwei Arten von Terminalen:
      \begin{enumerate}
      \item Terminale, die keinen zusätzlichen Wert haben.  Hierbei handelt es sich 
            um die Operator-Symbole, die beiden Klammer-Symbole und das Semikolon.  Die Syntax zur
            Deklaration solcher Terminale ist 
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{terminal} $t_1$, $\cdots$, $t_n$;
            \\[0.2cm]
            Durch diese Deklaration werden die Symbole $t_1$, $\cdots$, $t_n$ als Terminale
            deklariert.
      \item Terminale, denen ein Wert zugeordnet ist.  In diesem Fall muss der Typ
            dieses Wertes deklariert werden.  Die Syntax dafür ist 
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{terminal} \textsl{type} $t_1$, $\cdots$, $t_n$;
            \\[0.2cm]
            Hierbei spezifiziert \textsl{type} den Typ, der den Terminalen $t_1$, $\cdots$, $t_n$
            zugeordnet wird.
            
            Bei der Spezifikation eines Typs ist es wichtig zu beachten, dass zwischen dem Typ und
            dem ersten Terminal kein Komma steht, denn sonst würde der Typ ebenfalls als Terminal
            interpretiert.  
            
            In Zeile 6 spezifizieren wir beispielsweise, dass dem Terminal \texttt{NUMBER} ein
            Wert vom Typ \texttt{Integer} zugeordnet ist.  Damit das funktioniert, muss der Scanner
            jedes Mal,
            wenn er ein Terminal \texttt{NUMBER} an den Parser zurück geben soll, ein Objekt der
            Klasse  \texttt{Symbol} erzeugen, dass die entsprechende Zahl als Wert beinhaltet.
            In dem auf Seite \pageref{fig:calc.jflex}
            in Abbildung \ref{fig:calc.jflex} gezeigten Scanner geschieht dies beispielsweise
            in dadurch, dass mit Hilfe der Methode $\texttt{symbol}()$ der Konstruktor der
            Klasse \texttt{Symbol} aufgerufen wird, dem als zusätzliches Argument der Wert der Zahl
            übergeben wird.
      \end{enumerate}
\item In den Zeilen 8 und 9 werden die syntaktischen Variablen, die wir auch als Nicht-Terminale
      bezeichnen, deklariert.  Die Syntax ist dieselbe wie bei der Deklaration der Terminale, nur
      dass wir jetzt das Schlüsselwort ``\texttt{nonterminal}'' an Stelle von ``\texttt{terminal}''
      verwenden.  Auch hier gibt es wieder zwei Fälle:  Den in Zeile 8 deklarierten Nicht-Terminalen
      \texttt{expr\_list} und \texttt{expr\_part} wird kein Wert zugeordnet, während wir dem
      Nicht-Terminal \textsl{expr} einen Wert vom Typ \texttt{Integer} zuordnen, der sich aus der
      Auswertung des entsprechenden arithmetischen Ausdrucks ergibt.
\item Der letzte Teil einer \textsc{Cup}-Grammatik-Spezifikation enthält die Grammatik-Regeln. 
      Die allgemeine Form einer \textsc{Cup}-Grammatik-Regel ist
      \\[0.2cm]
      \hspace*{1.3cm}
      \textsl{var} \qote{::=} \textsl{body}$_1$ \qote{\{:} \textsl{action}$_1$ \qote{:\}} \\[0.1cm]
      \hspace*{2.05cm} \qote{|} \ \ \textsl{body}$_2$ \qote{\{:} \textsl{action}$_2$ \qote{:\}} \\[0.1cm]
      \hspace*{2.25cm} $\vdots$ \ \ \\[0.1cm]
      \hspace*{2.05cm} \qote{|} \ \ \textsl{body}$_n$ \qote{\{:} \textsl{action}$_n$ \qote{:\}}  \\[0.1cm]
      \hspace*{2.05cm} \qote{;} \\[0.1cm]
      Dabei gilt
      \begin{enumerate}
      \item \textsl{var} ist die syntaktische Variable, die von dieser Regel erzeugt wird.
      \item \textsl{body}$_i$ ist der Rumpf der $i$-ten Grammatik-Regel, der aus einer
            Liste von Terminalen und syntaktischen Variablen besteht.
      \item \textsl{action}$_i$ ist eine durch Semikolons getrennte Folge von \textsl{Java}-Anweisungen,
            die ausgeführt werden, falls der Stack des Shift/Reduce-Parsers, der die
            Symbole enthält, mit der zugehörigen Regel reduziert wird.
      \end{enumerate}
      Bei der Spezifikation einer Grammatik-Regel mit \textsc{Cup} weicht die Syntax von der
      Syntax, die in \textsc{Antlr} verwendet wird, an mehreren Stellen ab: 
      \begin{enumerate}
      \item Statt eines einfachen Doppelpunkts ``\texttt{:}'' wird die Zeichenreihe ``\texttt{::=}''
            verwendet, um die zu definierende Variable vom Rumpf der Grammatik-Regel zu trennen.
      \item Die Kommandos werden bei \textsc{Cup} in den Zeichenreihen ``\texttt{\{:}'' und
            ``\texttt{:\}}'' eingeschlossen, während bei \textsc{Antlr} die geschweiften Klammern
            ``\texttt{\{}'' und ``\texttt{\}}'' ausgereicht haben.
      \item Um auf die Werte, die einem Terminal oder einer syntaktischen Variablen zugeordnet sind,
            zuzugreifen, hatten wir bei \textsc{Antlr} Zuweisungen  verwendet.
            Stattdessen müssen wir nun jedem Symbol, 
            dessen Wert wir verwenden wollen, eine eigene Variable zuordnen, deren Namen wir
            getrennt von einem Doppelpunkt hinter das Symbol schreiben.  Um der durch die
            Grammatik-Regel definierten syntaktischen Variablen einen Wert zuzuweisen, verwenden wir
            das Schlüsselwort ``\texttt{RESULT}''.  Betrachten wir als Beispiel die folgende Regel:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{expr ::= expr:e PLUS prod:p \{: RESULT = e + p; :\};}
            \\[0.2cm]
            Mit \texttt{expr:e} sucht der Parser nach einem arithmetischen Ausdruck, dessen Wert in
            der Variablen \texttt{e} gespeichert wird.  Anschließend wird ein Plus-Zeichen gelesen
            und darauf folgt wieder ein Produkt, dessen Wert jetzt in \texttt{p}
            gespeichert wird.  Der Wert des insgesamt gelesenen Ausdrucks wird dann durch die Zuweisung
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{RESULT = e + p;}
            \\[0.2cm]
            berechnet und der linken Seite der Grammatik-Regel zugewiesen.
      \item Ein weiterer Unterschied zwischen \textsc{Cup} und \textsc{Antlr} besteht darin,
            dass Nicht-Terminale nicht mehr durch den ihnen zugeordneten String repräsentiert werden
            können.  Daher können wir den String ``\texttt{PLUS}'' nicht durch den String
            ``\texttt{'+'}'' ersetzen.  
            An dieser Stelle sind \textsc{Cup}-Grammatiken leider nicht so gut lesbar wie die
            entsprechenden \textsc{Antlr}-Grammatiken.
            Der Grund dafür ist, dass bei  \textsc{Cup} zum Scannen ein separates
            Werkzeug, nämlich \textsl{JFlex}, zum Scannen verwendet wird.  Demgegenüber
            wird bei \textsc{Antlr} der Scanner zusammen mit dem Parser in derselben
            Datei spezifiziert und das Werkzeug \textsc{Antlr} erzeugt aus dieser Datei
            sowohl einen Parser als auch einen Scanner.
      \item Ein weiterer wichtiger Unterschied zwischen \textsc{Cup} und \textsc{Antlr} besteht
            darin, dass \textsc{Cup} im Gegensatz zu \textsc{Antlr} keine \textsc{Ebnf}-Grammatiken
            akzeptiert sondern nur gewöhnliche kontextfreie Grammatiken verarbeiten kann.  Damit stehen
            uns die Operatoren ``\texttt{*}'', ``\texttt{+}'' und ``\texttt{?}'' bei der
            Spezifikation der Grammatik nicht zur Verfügung.
      \end{enumerate}
\end{enumerate}
Um aus der in Abbildung \ref{fig:calc.cup} gezeigten \textsc{Cup}-Spezifikation einen Parser zu
erzeugen, müssen wir diese zunächst mit dem Befehl
\\[0.2cm]
\hspace*{1.3cm}
\texttt{java -jar /usr/local/lib/java-cup-11b.jar calc.cup}
\\[0.2cm]
übersetzen.  Damit dies funktioniert müssen Sie die Datei
\\[0.2cm]
\hspace*{1.3cm}
 \texttt{java-cup-11b.jar} 
\\[0.2cm]
in dem Verzeichnis 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{/usr/local/lib}
\\[0.2cm]
ablegen.  Sollten Sie unter \textsl{Windows} arbeiten, müssen Sie statt dessen ein geeignetes anderes
Verzeichnis wählen.  Eine Möglichkeit, den Aufruf zu vereinfachen, besteht unter Unix darin, dass Sie sich
eine Datei \texttt{cup} mit folgendem Inhalt irgendwo in Ihrem Pfad ablegen:
\begin{verbatim}
    #!/bin/bash 
    java -jar /usr/local/lib/java-cup-11b.jar  $@
\end{verbatim} %$
Unter \textsl{Windows} können Sie sich statt dessen eine entsprechende \texttt{.bat}-Datei anlegen.
Danach können Sie \textsc{Cup} einfacher mit dem Befehl
\\[0.2cm]
\hspace*{1.3cm}
\texttt{cup} \textsl{calc.cup}
\\[0.2cm]
aufrufen.  Dieser Befehl erzeugt verschiedene \textsl{Java}-Dateien.
\begin{enumerate}
\item Die Datei \texttt{ExprParser.java} enthält die Klasse \texttt{ExprParser}, die den eigentlichen
      Parser enthält.  Wenn Sie diese Klassse später übersetzen wollen, müssen Sie dafür
      sorgen, dass die Datei \texttt{java-cup-11b-runtime.jar} im \texttt{CLASSPATH} liegt.
\item Die Datei \texttt{ExprParserSym.java} enthält die Klasse \texttt{ExprParserSym}, welche die verschiedenen
      Symbole als statische Konstanten  der  Klasse \texttt{ExprParserSym} definiert.  
      Diese Konstanten werden später im von \textsl{JFlex} erzeugten Scanner verwendet. Abbildung
      \ref{fig:sym.java} auf Seite \pageref{fig:sym.java} zeigt diese Klasse.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class ExprParserSym {
      /* terminals */
      public static final int MINUS   = 4;
      public static final int DIVIDE  = 6;
      public static final int NUMBER  = 10;
      public static final int MOD     = 7;
      public static final int SEMI    = 2;
      public static final int EOF     = 0;
      public static final int PLUS    = 3;
      public static final int error   = 1;
      public static final int RPAREN  = 9;
      public static final int TIMES   = 5;
      public static final int LPAREN  = 8;
      public static final String[] terminalNames = new String[] {
          "EOF",
          "error",
          "SEMI",
          "PLUS",
          "MINUS",
          "TIMES",
          "DIVIDE",
          "MOD",
          "LPAREN",
          "RPAREN",
          "NUMBER"
      };
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ExprParserSym}.}
\label{fig:sym.java}
\end{figure}

\noindent
Neben dem Parser wird noch ein Scanner benötigt.  Diesen werden wir im nächsten Abschnitt präsentieren.
Um mit dem Parser arbeiten zu können, brauchen wir eine Klasse, welche die Methode
$\texttt{main}()$ enthält.  Abbildung \ref{fig:Calculator.java} auf Seite
\pageref{fig:Calculator.java} zeigt eine solche Klasse.  Wir
erzeugen dort in Zeile 7 einen \texttt{InputStream}, der aus der Datei liest, deren Name wir als
erstes Argument übergeben.   In der darauf folgenden Zeile wird der \texttt{InputStream} in einen
\texttt{Reader} verwandelt.  Aus dem \texttt{Reader} erzeugen wir einen \texttt{Scanner}.  Mit
diesem \texttt{Scanner} können wir schließlich den Parser erzeugen, den wir dann in Zeile 11 mit
Hilfe der Methode \texttt{parse()} starten, wobei eventuelle Ausnahmen noch abgefangen werden müssen.
Falls mit dem Start-Symbol der Grammatik ein Wert assoziert ist, so wird dieser Wert von
der Methode $\texttt{parse}()$ als Ergebnis zurück gegeben, andernfalls gibt die Methode den Wert
\texttt{null} zurück.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java_cup.runtime.*;
    import java.io.*;
    
    public class Calculator {
        public static void main(String[] args) {
            try {
                InputStream fileStream = new FileInputStream(args[0]);
                Reader      reader     = new InputStreamReader(fileStream);
                Scanner     scanner    = new Yylex(reader);
                ExprParser  parser     = new ExprParser(scanner); 
                parser.parse(); 
            } catch (Exception e) {}
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Calculator}.}
\label{fig:Calculator.java}
\end{figure}
\vspace*{\fill}
\pagebreak

\vspace*{\fill}
\pagebreak


\section{Generierung eines \textsc{Cup}-Scanner mit Hilfe von \textsl{Flex}}
Wir zeigen in diesem Abschnitt, wie wir mit Hilfe von \textsl{JFlex} einen Scanner
für den im letzten Abschnitt erzeugten Parser erstellen können.
Der Scanner, den wir benötigen, muss in der Lage sein, Zahlen und arithmetische
Operatoren zu erkennen.  Abbildung \ref{fig:calc.jflex} auf Seite 
\pageref{fig:calc.jflex} zeigt einen solchen Scanner, den wir jetzt im Detail diskutieren.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java_cup.runtime.*;
          
    %%
       
    %char
    %line
    %column
    %cupsym ExprParserSym
    %cup
    %unicode
       
    %{   
        private Symbol symbol(int type) {
            return new Symbol(type, yychar, yychar + yylength());
        }
        
        private Symbol symbol(int type, Object value) {
            return new Symbol(type, yychar, yychar + yylength(), value);
        }
    %}
    
    %eofval{
        return new Symbol(ExprParserSym.EOF);
    %eofval}
       
    %%
       
    ";"           { return symbol( ExprParserSym.SEMI   ); } 
    "+"           { return symbol( ExprParserSym.PLUS   ); }
    "-"           { return symbol( ExprParserSym.MINUS  ); }
    "*"           { return symbol( ExprParserSym.TIMES  ); }
    "/"           { return symbol( ExprParserSym.DIVIDE ); }
    "%"           { return symbol( ExprParserSym.MOD    ); }
    "("           { return symbol( ExprParserSym.LPAREN ); }
    ")"           { return symbol( ExprParserSym.RPAREN ); }
    
    0|[1-9][0-9]* { return symbol(ExprParserSym.NUMBER, new Integer(yytext())); }
    
    [ \t\v\n\r]   { /* skip white space */ }   
    
    [^]           { throw new Error("Illegal character '" + yytext() + 
                                    "' at line " + yyline + 
                                    ", column "  + yycolumn); }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ein Scanner für arithmetische Ausdrücke}
\label{fig:calc.jflex}
\end{figure}

\begin{enumerate}
\item In Zeile 1 importieren wir alle Klassen des Paketes \texttt{java\_cup.runtime}.
      Dieses Paket enthält insbesondere die Definition der Klasse \texttt{Symbol}, mit der 
      in einem \textsc{Cup}-Parser Terminale und Nicht-Terminale beschrieben werden.
      Daher muss dieses Paket bei jedem Scanner importiert werden, der an einen von
      \textsc{Cup} erzeugten Parser angeschlossen werden soll.
\item In den Zeilen 5 bis 7 spezifizieren wir, dass der Scanner die Anzahl der insgesamt
      gelesenen Zeichen, die Anzahl der gelesenen Zeilen und die Anzahl der in der aktuellen Zeile
      gelesenen Zeichen automatisch berechnen soll.  Dadurch können wir später im Parser
      Syntax-Fehler präzise lokalisieren.
\item Zeile 8 spezifiziert mit dem Schlüsselwort ``\texttt{\%cupsym}'', 
      dass die vom Scanner zurückzugebenden Symbole in der Klasse \texttt{ExprParserSym} definiert
      werden.  Diese Klasse wurde von \textsc{Cup} erzeugt.  Der Name dieser Klasse ergibt sich aus
      dem Namen der Klasse des Parsers durch Anhängen von ``\texttt{Sym}'', das für \emph{Symbol} steht.
      Die Klasse des Parsers hatten wir seinerzeit in der Datei ``\texttt{calc.cup}''  mit Hilfe 
      des Schlüsselworts ``\texttt{class}'' spezifiziert.
\item Zeile 9 spezifiziert mit dem Schlüsselwort ``\texttt{\%cup}'', 
      dass der Scanner an einen \textsc{Cup}-Parser angeschlossen  werden soll.
\item In den Zeilen 12 bis 20 definieren wir zwei Hilfs-Methoden, die Objekte vom Typ 
      \texttt{Symbol} erzeugen.  Der Scanner muss Objekte von diesem Typ an den Parser zurück
      liefern.  Die in dem Paket \texttt{java\_cup.runtime} definierte Klasse \texttt{Symbol} stellt
      verschiedene Konstruktoren für diese Klasse zur Verfügung.  Wir stellen die wichtigsten 
      Konstruktoren vor.
      \begin{enumerate}
      \item \texttt{public Symbol(int \textsl{symbolID});}

            Dieser Konstruktor bekommt als Argument eine natürliche Zahl, die festlegt,
            welche Art von Symbol 
            definiert werden soll.  Diese Zahl bezeichnen wir als \emph{Symbol-Nummer}.
            Jedem Terminal und jeder syntaktische Variablen entspricht genau Symbol-Nummer. 
            Die Kodierung der Symbol-Nummern wird von dem Parser-Generator \textsc{Cup} 
            in der Klasse \texttt{ExprParserSym} festgelegt.  Abbildung \ref{fig:sym.java}
            auf Seite \pageref{fig:sym.java} zeigt diese von \textsc{Cup} erzeugte Klasse.
      \item \texttt{public Symbol(int \textsl{symbolID}, Object \textsl{value});}

            Dieser Konstruktor bekommt zusätzlich zur Symbol-Nummer einen \emph{Wert}, der im Symbol
            abgespeichert wird. Dieser Wert hat den Typ \texttt{Object}, wodurch der Typ so
            allgemein wie möglich ist.  Dieser
            Konstruktor wird benutzt, wenn Terminale, die einen Wert haben, wie beispielsweise
            Zahlen, vom Scanner an den Parser zurück gegeben werden sollen.
      \item \texttt{public Symbol(int \textsl{symbolID}, int \textsl{start}, int \textsl{end})}

            Dieser Konstruktor hat zusätzlich zur Symbol-Nummer die Argumente \texttt{start}  und
            \texttt{stop}, die den Anfang und das Ende des erkannten Terminals festlegen.  Die Variable
            \texttt{start} gibt die Position des ersten Zeichens im Text an, während \texttt{end}
            die Position des letzten Zeichens des Tokens angibt.  Diese Information ist nützlich,
            um später im Parser Syntax-Fehler besser lokalisieren zu können.
      \item \texttt{public Symbol(int \textsl{symbolID}, int  \textsl{start}, int \textsl{end},
                    Objekt \textsl{value})}

            Dieser Konstruktor erhält zusätzlich zur Symbol-Nummer und Position des gelesenen Tokens noch
            den Wert, der diesem Token zugeordnet ist.
      \end{enumerate}
      Bei der Implementierung der beiden Hilfs-Methoden mit dem Namen $\texttt{symbol}()$ verwenden
      wir die Funktion $\texttt{yylength}()$.  Diese Funktion wird von \textsl{jflex} zur Verfügung
      gestellt und gibt die Länge des Strings zurück, der dem zuletzt erkannten Tokens entspricht.
\item In den Zeilen 28 bis 35 erkennen wir die arithmetischen Operatoren und die Klammer-Symbole.
      Zur Spezifikation des zurückgegebenen Token verwenden wir dabei die in der Klasse \texttt{ExprParserSym}
      definierten Konstanten \texttt{SEMI}, \texttt{PLUS}, etc. 
\item In Zeile 37 erkennen wir mit dem regulären Ausdruck ``\texttt{0|[1-9][0-9]*}'' eine natürliche
      Zahl.  Diese wandeln wir durch den Konstruktor-Aufruf 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{new Integer(yytext())}
      \\[0.2cm]
      in ein Objekt vom Typ \texttt{Integer} um, wobei der String, der in eine Zahl umgewandelt wird, von der
      Funktion $\texttt{yytext}()$ geliefert wird.  Anschließend geben wir ein Objekt der Klasse \texttt{Symbol} zurück,
      in dem diese Zahl als mit dem Symbol assoziierter Wert abgespeichert wird.
\item In Zeile 39 überlesen wir Leerzeichen, Tabulatoren und Zeilen-Umbrüche.
      Das Überlesen geschieht dadurch, dass wir in diesem Fall kein Symbol an den Parser zurück
      geben, denn die semantische Aktion enthält keinen \texttt{return}-Befehl.
\item Falls ein beliebiges anderes Zeichen gelesen wird, geben wir mit der Regel, die in Zeile 41 
      beginnt, eine Fehlermeldung aus.  Dabei greifen wir auf die Variablen 
      \texttt{yyline} und \texttt{yycolumn} zurück, damit der Fehler lokalisiert werden kann.
\end{enumerate}
Durch den Aufruf
\\[0.2cm]
\hspace*{1.3cm}
\texttt{jflex calc.jflex}
\\[0.2cm]
erzeugt \textsl{JFlex} aus der Datei \texttt{clac.jflex} den Scanner in der Klasse \texttt{Yylex}.
Wir hatten in Abbildung 
\ref{fig:Calculator.java} gesehen, wie diese Klasse an den Parser angebunden wird.



\section{Shift/Reduce und Reduce/Reduce-Konflikte}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    import java_cup.runtime.*;
    
    terminal           PLUS, MINUS, TIMES, DIVIDE, MOD;
    terminal           UMINUS, LPAREN, RPAREN;
    terminal Integer   NUMBER;
    
    nonterminal Integer expr;
    
    expr ::= expr PLUS   expr
          |  expr MINUS  expr
          |  expr TIMES  expr
          |  expr DIVIDE expr
          |  expr MOD    expr
          |  NUMBER               
          |  MINUS expr
          |  LPAREN expr RPAREN   
          ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\textsc{Cup}-Spezifikation eines Parsers für arithmetische Ausdrücke}
\label{fig:calc-ambiguous.cup}
\end{figure}

Wir betrachten nun ein weiteres Beispiel.  Abbildung \ref{fig:calc-ambiguous.cup} zeigt eine 
\textsc{Cup}-Spezifikation einer Grammatik, die offenbar mehrdeutig ist, da die Präzedenzen der
arithmetischen Operatoren durch diese Grammatik nicht festgelegt werden.
  Mit dieser Grammatik ist beispielsweise nicht klar, ob der String
\\[0.2cm]
\hspace*{1.3cm} 
``\texttt{1 + 2 * 3}'' \quad als \quad  ``\texttt{(1 + 2) * 3}'' \quad oder als \quad ``\texttt{1 + (2 * 3)}''
\\[0.2cm]
interpretiert werden soll.   Wir hatten im letzten Kapitel schon gesehen, dass es in einer
mehrdeutigen Grammatik immer Shift/Reduce- oder Reduce/Reduce-Konflikte geben muss, denn jede
LALR-Grammatik ist eindeutig.  Wenn wir versuchen, die Grammatik aus Abbildung
\ref{fig:calc-ambiguous.cup} mit \textsc{Cup} zu übersetzen und wenn wir dabei zusätzlich die Option 
``\texttt{-dump}'' angeben, der Aufruf von \textsc{Cup} hat dann die Form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{cup -dump calc.cup}
\\[0.2cm]
so erhalten wir eine große Zahl von Shift/Reduce-Konflikten angezeigt.
Beispielsweise erhalten wir die folgende Fehlermeldung:
\begin{verbatim}
    Warning : *** Shift/Reduce conflict found in state #12
      between expr ::= expr TIMES expr (*) 
      and     expr ::= expr (*) PLUS expr 
      under symbol PLUS
      Resolved in favor of shifting.
\end{verbatim}
Statt des Zeichens ``$\bullet$'' benutzt \textsc{Cup} den String
``\texttt{(*)}'' zur Darstellung der Position in einer markierten Regel.
Die obige Fehlermeldung zeigt uns an, dass es zwischen der markierten Regel
\\[0.2cm]
\hspace*{1.3cm}
$R_1 \;:=\; 
\Bigl(\textsl{expr} \rightarrow \textsl{expr} \quoted{*} \textsl{expr}\;\bullet\Bigr)$
\\[0.2cm]
und der markierten Regel
\\[0.2cm]
\hspace*{1.3cm}
$R_2 \; := \; 
\Bigl(\textsl{expr} \rightarrow \textsl{expr} \bullet \quoted{+} \textsl{expr}\Bigr)$
\\[0.2cm]
einen Shift/Reduce-Konflikt gibt:  Die beiden markierten  Regeln $R_1$ und $R_2$
sind Elemente eines Zustands, der von \textsc{Cup} intern mit der Nummer 12 versehen
worden ist.  Der Zustand mit der Nummer 12 hat folgende Form:
\begin{verbatim}
    lalr_state [12]: {
      [expr ::= expr (*) MOD expr ,    {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr (*) MINUS expr ,  {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr (*) DIVIDE expr , {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr (*) TIMES expr ,  {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr (*) PLUS expr ,   {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr MINUS expr (*) ,  {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
    }
\end{verbatim}
Damit können wir jetzt den
Shift/Reduce-Konflikt interpretieren: Im Zustand 12 ist der Parser entweder dabei, die
Eingabe mit der Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{expr} \rightarrow \textsl{expr} \quoted{*} \textsl{expr}$
\\[0.2cm]
zu reduzieren, oder der Parser ist gerade dabei, die rechte Seite der Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{expr} \rightarrow \textsl{expr} \quoted{+} \textsl{expr}$
\\[0.2cm]
zu erkennen, wobei er bereits eine \textsl{expr} erkannt hat und nun als nächstes das
Token ``\texttt{+}'' erwartet wird.  Da das Token ``\texttt{+}'' auch in der Follow-Menge der
erweiterten markierten Regel $R_1$ liegen kann, ist an dieser Stelle unklar, ob das Token
``\texttt{+}'' auf den 
Stack geschoben werden soll, oder ob stattdessen mit der Regel $R_1$ reduziert werden
muss.  Bei einem Shift/Reduce-Konflikt entscheidet sich der von \textsc{Cup} erzeugte
Parser immer dafür, das Token auf den Stack zu schieben.


\section{Operator-Präzendenzen \label{section:operator-precedence}}
Es ist mit   \textsc{Cup} möglich, Shift/Reduce-Konflikte durch die Angabe von
\emph{Operator-Präzedenzen} 
aufzulösen.  Abbildung \ref{fig:calc-precedence.cup} zeigt die Spezifikation einer Grammatik zur
Erkennung arithmetischer Ausdrücke, die aus Zahlen und den binären Operatoren ``\texttt{+}'',
``\texttt{-}'', ``\texttt{*}'', ``\texttt{/}'' und ``\texttt{\symbol{94}}'' aufgebaut sind.   Mit
Hilfe der Schlüsselwörter 
\\[0.2cm]
\hspace*{1.3cm}
``\texttt{precedence left}'' \quad und \quad ``\texttt{precedence right}'' 
\\[0.2cm]
haben wir festgelegt, dass die Operatoren ``\texttt{+}'', ``\texttt{-}'', ``\texttt{*}'' und
``\texttt{/}'' \emph{links-assoziativ} sind, ein Ausdruck der Form 
\\[0.2cm]
\hspace*{1.3cm}
$3 - 2 - 1$ \quad wird also als \quad $(3 - 2) - 1$ \quad und nicht als \quad $3 - (2-1)$
\\[0.2cm]
gelesen.  Demgegenüber ist der Operator ``\texttt{\symbol{94}}'', der in der \textsc{Cup}-Grammatik
mit ``\texttt{POW}'' bezeichnet wird und die Potenzbildung bezeichnet,
\emph{rechts-assoziativ}, der Ausdruck 
\\[0.2cm]
\hspace*{1.3cm}
$4 \texttt{\symbol{94}} 3 \texttt{\symbol{94}} 2$ \quad wird daher als \quad
$4^{\mbox{(}3^2\mbox{)}}$ \quad  und nicht als \quad $\bigl(4^3\bigr)^2$
\\[0.2cm]
interpretiert.   Die Reihenfolge, in der die Assoziativität der Operatoren spezifiziert werden, legt die
\emph{Präzedenzen}, die auch als \emph{Bindungsstärken} bezeichnet werden, fest.  Dabei ist die
Bindungsstärke umso größer, je später der Operator spezifiziert wird.  In unserem konkreten Beispiel bindet
der Exponentiations-Operator ``\texttt{\symbol{94}}'' also am stärksten, während die Operatoren ``\texttt{+}'' und
``\texttt{-}'' am schwächsten binden.  Bei der in Abbildung \ref{fig:calc-precedence.cup} gezeigten Grammatik
ordnet \textsc{Cup} den Operatoren die Bindungsstärke nach der folgenden Tabelle zu:

\begin{center}
\begin{tabular}[t]{|c|c|c|}
\hline
Operator       & Bindungsstärke & Assoziativität \\
\hline
\hline
``\texttt{+}''  & 1             &  links         \\
\hline
``\texttt{-}''  & 1             &  links         \\
\hline
``\texttt{*}''  & 2             &  links         \\
\hline
``\texttt{/}''  & 2             &  links         \\
\hline
``\texttt{\symbol{94}}'' & 3             &  rechts        \\
\hline
\end{tabular}
\end{center}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java_cup.runtime.*;
    class  ExprParser;
    
    terminal         SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD, POW;
    terminal         UMINUS, LPAREN, RPAREN;
    
    terminal Double  NUMBER;
    
    nonterminal        expr_list, expr_part;
    nonterminal Double expr;
    
    precedence left   PLUS, MINUS;
    precedence left   TIMES, DIVIDE, MOD;
    precedence right  UMINUS, POW;
    
    start with expr_list;
    
    expr_list ::= expr_list expr_part 
               |  expr_part
               ;
    
    expr_part ::= expr:e {: System.out.println("result = " + e); :} SEMI 
               ;
    
    expr ::= expr:e1 PLUS   expr:e2 {: RESULT = e1 + e2; :} 
          |  expr:e1 MINUS  expr:e2 {: RESULT = e1 - e2; :} 
          |  expr:e1 TIMES  expr:e2 {: RESULT = e1 * e2; :}
          |  expr:e1 DIVIDE expr:e2 {: RESULT = e1 / e2; :} 
          |  expr:e1 MOD    expr:e2 {: RESULT = e1 % e2; :} 
          |  expr:e1 POW    expr:e2 {: RESULT = Math.pow(e1, e2); :} 
          |  NUMBER:n               {: RESULT = n;       :} 
          |  MINUS expr:e           {: RESULT = - e;     :} %prec UMINUS
          |  LPAREN expr:e RPAREN   {: RESULT = e;       :} 
          ;
\end{Verbatim}
%$
\vspace*{-0.3cm}
\caption{Auflösung der Shift/Reduce-Konflikte durch Operator-Präzedenzen.}
\label{fig:calc-precedence.cup}
\end{figure}

Wie erläutern nun, wie diese Bindungsstärken benutzt werden, um Shift/Reduce-Konflikte aufzulösen.
\textsc{Cup} geht folgendermaßen vor:
\begin{enumerate}
\item Zunächst wird jeder Grammatik-Regel eine \emph{Präzedenz} zugeordnet.
      Die Präzedenz ist dabei die Bindungsstärke des letzten in der Regel auftretenden Operators.
      Für den Fall, dass eine Regel mehrere Operatoren enthält, für die eine Bindungsstärke spezifiziert
      wurde, wird zur Festlegung der Bindungsstärke also der Operator herangezogen, der in
      der Regel am weitesten 
      rechts steht.  In unserem Beispiel haben die einzelnen Regeln damit die folgenden Präzedenzen:
      \begin{center}
        \begin{tabular}[t]{|l|c|}
          \hline
          Regel                          & Präzedenz  \\
          \hline
          \hline
          $E \rightarrow E \quoted{+} E$ & 1          \\
          \hline
          $E \rightarrow E \quoted{-} E$ & 1          \\
          \hline
          $E \rightarrow E \quoted{*} E$ & 2          \\
          \hline
          $E \rightarrow E \quoted{/} E$ & 2          \\
          \hline
          $E \rightarrow E \quoted{\symbol{94}} E$ & 3 \\
          \hline
          $E \rightarrow \quoted{(} E \quoted{)}$ & --- \\
          \hline
          $E \rightarrow N$ & --- \\
          \hline
        \end{tabular}
      \end{center}
      Für die Regeln, die keinen Operator enthalten, für den eine Bindungsstärke spezifiziert ist,
      bleibt die Präzedenz unspezifiziert.
\item Ist $s$ ein Zustand, in dem zwei Regeln $r_1$ und $r_2$ der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $r_1 = (a \rightarrow \beta \bullet o \;\delta:L_1)$ \quad und \quad
      $r_2 = (c \rightarrow \gamma \bullet : L_2)$ \quad mit \quad $o \in L_2$
      \\[0.2cm]
      vorkommen, so gibt es bei der Berechnung von 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(s, o)$
      \\[0.2cm]
      zunächst einen Shift/Reduce-Konflikt.  Falls dem Operator $o$ die Präzedenz $p(o)$
      zugeordnet worden ist und wenn außerdem die Regel $r_2$, mit der reduziert werden würde, die
      Präzedenz  $p(r_2)$ hat, so wird der Shift/Reduce-Konflikt in Abhängigkeit von der relativen
      Größe   der beiden Zahlen $p(o)$ und $p(r_2)$ aufgelöst.  Hier werden fünf Fälle unterschieden:
      \begin{enumerate}
      \item $p(o) > p(c \rightarrow \gamma)$: 
            In diesem Fall bindet der Operator $o$ stärker.  Daher wird das Token $o$  
            in diesem Fall auf den Stack geschoben:
            \hspace*{1.3cm}
            \\[0.2cm]
            $\textsl{action}(s,o) = \langle \texttt{shift}, \textsl{goto}(s,o) \rangle$.
            \\[0.2cm]
            Dass diese Regel sinnvoll ist, sehen wir, wenn wir beispielsweise den Eingabe-String
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1+2*3}$
            \\[0.2cm]
            mit den Grammatik-Regeln 
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \quoted{+} E \mid E \quoted{*} E \mid \textsc{Number}$
            \\[0.2cm]
            parsen.  Betrachten wir die Situation, bei der der Teilstring ``\texttt{1+2}''
            bereits gelesen wurde und nun als nächstes das Token ``\texttt{*}''
            verarbeitet werden soll.  Der LALR-Parser ist dann in dem folgenden Zustand:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
            \bigl\{ 
            & E & \rightarrow & E \bullet \squoted{*} E: \{\symbol{36}, \squoted{*}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \bullet \squoted{+} E: \{\symbol{36}, \squoted{*}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \squoted{+} E \;\bullet: \{\symbol{36}, \squoted{*}, \squoted{+} \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            Wenn in diesem Zustand als nächstes Zeichen ein ``\texttt{*}'' gelesen wird, so darf der
            bisher gelesene String ``\texttt{1+2}'' nicht mit der Regel 
            $E \rightarrow E \squoted{+} E$ reduziert werden, denn wir wollen die 2 ja zunächst mit 3 
            multiplizieren.  Statt dessen muss also das Zeichen 
            ``\texttt{*}'' auf den Stack geschoben werden.
      \item $p(o) < p(c \rightarrow \gamma)$: 
            Jetzt bindet der Operator, der in der Regel $r_2$ auftritt, stärker als der
            Operator $o$.  Daher wird in diesem Fall zunächst mit der Regel $r_2$ reduziert, wir haben 
            also 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{reduce}, r_2 \rangle$.
            \\[0.2cm]
            Dass diese Regel sinnvoll ist, sehen wir, wenn wir beispielsweise den Eingabe-String
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1*2+3}$
            \\[0.2cm]
            mit den Grammatik-Regeln 
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \quoted{+} E \mid E \quoted{*} E \mid \textsc{Number}$
            \\[0.2cm]
            parsen.  Betrachten wir die Situation, bei der der Teilstring ``\texttt{1*2}''
            bereits gelesen wurde und nun als nächstes das Token ``\texttt{+}''
            verarbeitet werden soll.  Der LALR-Parser ist dann in dem folgenden Zustand:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
         \bigl\{ 
            & E & \rightarrow & E \bullet \squoted{*} E: \{\symbol{36}, \squoted{*}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \bullet \squoted{+} E: \{\symbol{36}, \squoted{*}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \squoted{*} E \;\bullet: \{\symbol{36}, \squoted{*}, \squoted{+} \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            Wenn in diesem Zustand als nächstes Zeichen ein ``\texttt{+}'' gelesen wird, so soll
            der bisher gelesene String ``\texttt{1*2}''  mit der Regel 
            $E \rightarrow E \squoted{*} E$ reduziert werden, denn wir wollen die 1 ja zunächst mit 2 
            multiplizieren.  
      \item $p(o) = p(c \rightarrow \gamma)$ und der Operator $o$ ist links-assoziativ:
            Dann wird zunächst mit der Regel $r_2$ reduziert, wir haben
            also 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{reduce}, r_2 \rangle$.
            \\[0.2cm]
            Dass diese Regel sinnvoll ist, sehen wir, wenn wir beispielsweise den Eingabe-String
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1-2-3}$
            \\[0.2cm]
            mit den Grammatik-Regeln 
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \quoted{+} E \mid E \quoted{-} E \mid \textsc{Number}$
            \\[0.2cm]
            parsen.  Betrachten wir die Situation, bei der der Teilstring ``\texttt{1-2}''
            bereits gelesen wurde und nun als nächstes das Token ``\texttt{-}''
            verarbeitet werden soll.  Der LALR-Parser ist dann in dem folgenden Zustand:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
         \bigl\{ 
            & E & \rightarrow & E \bullet \squoted{-} E: \{\symbol{36}, \squoted{-}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \bullet \squoted{+} E: \{\symbol{36}, \squoted{-}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \squoted{-} E \;\bullet: \{\symbol{36}, \squoted{-}, \squoted{+} \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            Wenn in diesem Zustand als nächstes Zeichen ein ``\texttt{-}'' gelesen wird, so soll
            der bisher gelesene String ``\texttt{1-2}'' mit der Regel 
            $E \rightarrow E \squoted{-} E$ reduziert werden, denn wir wollen von der Zahl 1 ja
            zunächst die Zahl 2 subtrahieren.  
      \item $p(o) = p(c \rightarrow \gamma)$ und der Operator $o$ ist rechts--assoziativ:
            In diesem Fall wird $o$ auf den
            Stack geschoben:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{shift}, \textsl{goto}(s,o) \rangle$.
            \\[0.2cm]
            Wenn wir diesen Fall verstehen wollen, reicht es aus, den String
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{2\symbol{94}3\symbol{94}4}$
            \\[0.2cm]
            mit den Grammatik-Regeln
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \,\texttt{\symbol{94}}\, E \mid \textsc{Number}$
            \\[0.2cm]
            zu parsen und die Situation zu betrachten, bei der der Teilstring
            ``\texttt{1\symbol{94}2}'' bereits verarbeitet wurde und als nächstes Zeichen nun
            der Operator ``\texttt{\symbol{94}}'' gelesen wird.
            Der LALR-Parser ist dann in dem folgenden Zustand:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\bigl\{ 
             E  \rightarrow E \bullet \quoted{\texttt{\symbol{94}}} E:
             \{\symbol{36},\quoted{\texttt{\symbol{94}}} \},\;  E \rightarrow  E
             \squoted{\texttt{\symbol{94}}} E \;\bullet: \{\symbol{36},\quoted{\texttt{\symbol{94}}}\}
            \bigr\}.
            $
            \\[0.2cm]
            Hier muss als nächstes das Token \quoted{\texttt{\symbol{94}}} auf den Stack geschoben
            werden, denn wir wollen ja zunächst den Ausdruck ``$3 \texttt{\symbol{94}} 4$'' berechnen.
      \item $p(o) = p(c \rightarrow \gamma)$ und der Operator $o$ hat keine Assoziativität:
            In diesem Fall liegt ein Syntax-Fehler vor:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \textsl{error}$.
            \\[0.2cm]
            Diesen Fall verstehen Sie, wenn Sie versuchen, einen String der Form
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{1 < 1 < 1}
            \\[0.2cm]
            mit den Grammatik-Regeln
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \quoted{<} E \mid E \quoted{+} E \mid \textsc{Number}$
            \\[0.2cm]
            %$
            zu parsen.  In dem Moment, in dem Sie den Teilstring ``\texttt{1 < 1}'' gelesen haben
            und nun das nächste Token das Zeichen ``\texttt{<}'' ist, erkennen Sie, 
            dass es ein Problem gibt.  

            \remark
            Beachten Sie, dass auch in diesem Fall der Shift/Reduce-Konflikt aufgelöst
            wird, denn den Syntax-Fehler erhalten Sie erst beim Parsen,  während die
            Erstellung des Parsers selber fehlerfrei (sprich: ohne verbleibende Konflikte)
            verläuft.

            Um in \textsc{Cup} einen Operator $o$ als nicht-assoziativ zu deklarieren, 
            schreiben Sie:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{precedence nonassoc $o$}
      \item $p(o)$ ist undefiniert oder $p(c \rightarrow \gamma)$ ist undefiniert.

            In diesem Fall erzeugt \textsc{Cup} einen Shift/Reduce-Konflikt und gibt bei der
            Erzeugung des Parsers eine entsprechende Warnung aus.  Diese Warnung wird als Fehler
            gewertet,  wenn sie nicht durch Angabe der Option 
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{-expect} $n$
            \\[0.2cm]
            beim Aufruf von \textsc{Cup} unterdrückt wird.  Bei dieser Option ist $n$ die Anzahl der
            vom Benutzer erwarteten Konflikte. In diesem Fall wird der Konflikt dann per Default
            dadurch aufgelöst,  dass das betreffende Token auf den Stack geschoben wird. 
            Wir werden dieses Verhalten im nächsten Abschnitt an Hand eines Beispiels im Detail 
            diskutieren. 
      \end{enumerate}

\end{enumerate}
Die von \textsc{Cup} mit der Option ``\texttt{-dump}'' erzeugte Ausgabe zeigt im Detail, wie die
Shift/Reduce-Konflikt Konflikte aufgelöst worden sind.  Wir betrachten exemplarisch zwei Zustände in
der Datei, die für die in Abbildung \ref{fig:calc-precedence.cup} gezeigte Grammatik erzeugt wird.
\begin{enumerate}
\item Der Zustand Nummer 14 hat die in Abbildung \ref{fig:state14} gezeigte Form.
      Hier gibt es unter anderem einen Shift/Reduce-Konflikt zwischen den beiden markierten Regeln
      \\[0.2cm]
      \hspace*{1.3cm}
      $E \rightarrow E \bullet \quoted{+} E$ \quad und \quad
      $E \rightarrow E \quoted{*} E \bullet$, 
      \\[0.2cm]
      denn die erste Regel verlangt nach einem Shift, während die zweite Regel eine Reduktion fordert.
      Da die Regel $E \rightarrow E \quoted{*} E$ dieselbe Präzedenz wie der Operator ``\texttt{*}''
      und dieser eine höhere Präzedenz als $\quoted{+}$ hat, wird beispielsweise beim Lesen des Zeichens
      ``\texttt{+}'' mit der Regel $E \rightarrow E \quoted{*} E$ reduziert.
      Wird hingegen das Zeichen ``\texttt{\^}'' gelesen, so wird dieses geshiftet, denn
      dieses Zeichen hat eine höhere Priorität als die Regel
       $E \rightarrow E \quoted{*} E$.
    \begin{figure}[!ht]
    \centering
    \begin{Verbatim}[ frame         = lines, 
                      framesep      = 0.3cm, 
                      labelposition = bottomline,
                      numbers       = left,
                      numbersep     = -0.2cm,
                      xleftmargin   = 0.8cm,
                      xrightmargin  = 0.8cm,
                    ]
    lalr_state [14]: {
      [expr ::= expr (*) PLUS expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr TIMES expr (*) , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) POW expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) TIMES expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) MOD expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) MINUS expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) DIVIDE expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
    }

    From state #14
     [term 2:REDUCE(with prod 7)] [term 3:REDUCE(with prod 7)]
     [term 4:REDUCE(with prod 7)] [term 5:REDUCE(with prod 7)]
     [term 6:REDUCE(with prod 7)] [term 7:REDUCE(with prod 7)]
     [term 8:SHIFT(to state 9)] [term 11:REDUCE(with prod 7)]    
    \end{Verbatim} 
    %$
    \vspace*{-0.3cm}
    \caption{Der Zustand Nummer 14.}
    \label{fig:state14}
  \end{figure}
      Weiterhin gibt es einen Shift/Reduce-Konflikt zwischen den beiden markierten Regeln
      \\[0.2cm]
      \hspace*{1.3cm}
      $E \rightarrow E \bullet \quoted{*} E$ \quad und \quad
      $E \rightarrow E \quoted{*} E \bullet$.
      \\[0.2cm]
      Hier haben beide Regeln die gleiche Präzedenz.  Daher entscheidet die  Assoziativität.
      Da der Operator ``\texttt{*}'' links-assoziativ ist, wird mit der Regel
      $E \rightarrow E \quoted{*} E$ reduziert, falls das nächste Zeichen ein Multiplikations-Operator
      ``\texttt{*}'' ist.
\item Der Zustand Nummer 18 hat die in Abbildung \ref{fig:state18} gezeigte Form.
      Zunächst gibt es hier einen Shift/Reduce-Konflikt zwischen den Regeln
      \\[0.2cm]
      \hspace*{1.3cm}
      $E \rightarrow E \bullet \quoted{\symbol{94}} E$ \quad und \quad
      $E \rightarrow E \quoted{\symbol{94}} E  \bullet$,
      \\[0.2cm]
      wenn das nächste Token der Operator ``\texttt{\symbol{94}}'' ist.  Da der Operator 
      dieselbe Präzedenz 
      hat wie die Regel, entscheidet die Assoziativität.  Nun ist der Operator
      ``\texttt{\symbol{94}}'' rechts-assoziativ, daher wird in diesem Fall geshiftet.

    \begin{figure}[!ht]
    \centering
    \begin{Verbatim}[ frame         = lines, 
                      framesep      = 0.3cm, 
                      labelposition = bottomline,
                      numbers       = left,
                      numbersep     = -0.2cm,
                      xleftmargin   = 0.8cm,
                      xrightmargin  = 0.8cm,
                    ]
    lalr_state [18]: {
      [expr ::= expr POW expr (*) , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) PLUS expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) POW expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) TIMES expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) MOD expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) MINUS expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) DIVIDE expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
    }

    From state #18
     [term 2:REDUCE(with prod 10)] [term 3:REDUCE(with prod 10)]
     [term 4:REDUCE(with prod 10)] [term 5:REDUCE(with prod 10)]
     [term 6:REDUCE(with prod 10)] [term 7:REDUCE(with prod 10)]
     [term 8:SHIFT(to state 9)] [term 11:REDUCE(with prod 10)]
    \end{Verbatim} 
    %$
    \vspace*{-0.3cm}
    \caption{Der Zustand Nummer 18.}
    \label{fig:state18}
  \end{figure}

      Hier gibt es noch viele andere Shift/Reduce-Konflikte, die aber alle dieselbe Struktur haben.
      Exemplarisch betrachten wir den Shift/Reduce-Konflikt zwischen den Regeln
      \\[0.2cm]
      \hspace*{1.3cm}
      $E \rightarrow E \bullet \quoted{+} E$ \quad und \quad
      $E \rightarrow E \quoted{\symbol{94}} E  \bullet$,
      \\[0.2cm]
      der auftritt, wenn das nächste Token ein ``\texttt{+}'' ist.  Da die Regel 
      $E \rightarrow E \quoted{\symbol{94}} E$ die Präzedenz 3 hat, die größer ist als die Präzedenz 1 des
      Operators ``\texttt{+}'' wird dieser Konflikt dadurch aufgelöst, dass mit der Regel 
      $E \rightarrow E \quoted{\symbol{94}} E$ reduziert wird. 
\end{enumerate}    
\vspace*{\fill} \pagebreak

\exercise
Implementieren Sie einen \textsc{Cup}-Parser, der in der Lage ist, eine
\textsc{Cup}-Grammatik zu lesen und zusätzlich die folgenden Anforderungen erfüllt:
\begin{enumerate}
\item Die Grammatik soll intern in Form eines abstrakten Syntax-Baums abgespeichert werden.  
      In dem Verzeichnis 
      \\[0.2cm]
      \hspace*{1.3cm}
      \href{http://wwwlehre.dhbw-stuttgart.de/~stroetma/Formal-Languages/Exercises/Grammar2HTML/}{http://wwwlehre.dhbw-stuttgart.de/\symbol{126}stroetma/Formal-Languages/Exercises/Grammar2HTML/}
      \\[0.2cm]
      finden Sie verschiedene \textsl{Java}-Klassen, mit denen Sie einen solchen Syntax-Baum
      darstellen können.  Diese Klassen implementieren eine Methode \texttt{toString()}, mit deren
      Hilfe sich der Syntax-Baum im \textsc{Html}-Format ausgeben lässt.
\item Die semantischen Aktionen der Grammatik sollen unterdrückt werden.
\item Testen Sie Ihr Programm, indem Sie es sowohl auf sich selbst als auch auf die im Unterricht
      vorgestellte Grammatik für arithmetische Ausdrücke anwenden.
      Zusätzlich können Sie es auch auf die \texttt{C}-Grammatik, die Sie unter
      \\[0.2cm]
      \href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Cup/Grammars/c-grammar.cup}{https://github.com/karlstroetmann/Formal-Languages/blob/master/Cup/Grammars/c-grammar.cup}
      \\[0.2cm]
      im Netz finden, anwenden.
\end{enumerate}


\section{Das \emph{Dangling-Else}-Problem}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    class Dangling;

    terminal LPAREN, RPAREN, IF, ELSE, WHILE, LBRACE, RBRACE, ASSIGN, SEMI;
    terminal NUMBER, ID;
    
    nonterminal stmnt, stmntList, expr;
    
    start with stmnt;

    stmnt ::= IF LPAREN expr RPAREN stmnt
           |  IF LPAREN expr RPAREN stmnt ELSE stmnt
           |  WHILE LPAREN expr RPAREN stmnt
           |  LBRACE stmntList RBRACE
           |  ID ASSIGN expr SEMI
           ;
      
    stmntList ::= stmntList stmnt
               |  /* epsilon */
               ;
    
    expr ::= NUMBER
           ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Fragment einer Grammatik für die Sprache \texttt{C}}
\label{fig:dangling-else.y}
\end{figure}

\noindent
Bei der syntaktischen Beschreibung von Befehlen der Sprache \texttt{C} 
tritt bei der Behandlung
von \emph{if-then-else} Konstrukten ein Shift/Reduce-Konflikt auf, den wir jetzt analysieren wollen.
Abbildung \ref{fig:dangling-else.y} zeigt eine Grammatik, die einen Teil der Syntax von Befehlen der
Sprache \texttt{C} beschreibt.  Um uns auf das wesentliche konzentrieren zu können, sind dort die Ausdrücke
einfach nur Zahlen.  Das Token ``\texttt{ID}'' steht
für eine Variable, die Grammatik beschreibt also Befehle, die aus Zuweisungen, \emph{If-Abfragen},
\emph{If-Else-Abfragen} und \emph{While-Schleifen} aufgebaut sind.  Übersetzen wir diese Grammatik mit
\textsc{Cup}, so erhalten wir den in Abbildung \ref{fig:dangling-else.output} ausschnittsweise gezeigten
Shift/Reduce-Konflikt. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    Warning : *** Shift/Reduce conflict found in state #10
      between stmnt ::= IF LPAREN expr RPAREN stmnt (*) 
      and     stmnt ::= IF LPAREN expr RPAREN stmnt (*) ELSE stmnt 
      under symbol ELSE
      Resolved in favor of shifting.
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ein Shift/Reduce-Konflikt.}
\label{fig:dangling-else.output}
\end{figure}
%$

Der Konflikt entsteht bei der Berechnung von $\textsl{action}(\texttt{state \#10}, \texttt{else})$ zwischen den
beiden markierten Regeln
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{Statement} \rightarrow \quoted{if} \quoted{(} \texttt{EXPR} \quoted{)} \textsl{Statement}\;\; \bullet$ 
\quad und
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{Statement} \rightarrow 
\quoted{if} \quoted{(} \texttt{EXPR} \quoted{)} \textsl{Statement} \;\bullet \quoted{else} \textsl{Statement}$.
\\[0.2cm]
Die erste Regel verlangt nach einer Reduktion, die zweite Regel sagt, dass das Token 
\texttt{else} geshiftet werden soll.  Das dem Konflikt zu Grunde liegende Problem ist, dass die in Abbildung
\ref{fig:dangling-else.y} gezeigte Grammatik mehrdeutig ist, denn ein \textsl{Statement} der Form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{if (a = b) if (c = d) s = t; else u = v;}
\\[0.2cm]
kann auf die folgenden beiden Arten gelesen werden:
\begin{enumerate}
\item Die erste (und nach der Spezifikation der Sprache \texttt{C} auch korrekte) Interpretation 
      besteht darin, dass wir den Befehl wie folgt klammern:
      \begin{verbatim}
      if (a = b) {
          if (c = d) {
              s = t; 
          } else {
              u = v;
          }
      }
      \end{verbatim}
      \vspace*{-0.7cm}
\item Die zweite Interpretation, die nach der in Abbildung
      \ref{fig:dangling-else.y} gezeigten Grammatik ebenfalls zulässig wäre,
      würde den Befehl in der folgenden Form interpretieren:
      \begin{verbatim}
      if (a = b) {
          if (c = d) {
              s = t; 
          }
      } else {
          u = v;
      }
      \end{verbatim}
      \vspace*{-0.5cm}

      Diese Interpretation entspricht nicht der Spezifikation der Sprache \texttt{C}.
\end{enumerate}
Es gibt drei Möglichkeiten, das Problem zu lösen.
\begin{enumerate}
\item Tritt ein Shift/Reduce-Konflikt auf, der nicht durch Operator-Präzedenzen gelöst wird,
      so ist der Default, dass das nächste Token auf den Stack geschoben wird.  In dem konkreten
      Fall ist dies genau das, was wir wollen, weil dadurch das \texttt{else} immer mit dem letzten
      \texttt{if} assoziert wird.  Um die normalerweise bei Konfliken von \textsc{Cup}
      ausgelöste Fehlermeldung zu unterdrücken, müssen wir \textsc{Cup} mit der Option
      ``\texttt{-expect}'' wie folgt aufrufen:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{cup -expect 1 -dump dangling.cup}
      \\[0.2cm]
      Die Zahl \texttt{1} gibt hier die Anzahl der Konflikte an, die wir erwarten.
      So lange die spezifizierte Zahl mit der tatsächlich gefundenen Zahl an Konflikten übereinstimmt,
      erzeugt \textsc{Cup} einen Parser.
\item Die zweite Möglichkeit besteht darin, die Grammatik so umzuschreiben, dass die Mehrdeutigkeit
      verschwindet.   Die grundsätzliche Idee ist hier, zwischen zwei Arten von Befehlen zu
      unterscheiden.
      \begin{enumerate}
      \item Einerseits gibt es Befehle, bei denen jedem ``\texttt{if}'' auch ein ``\texttt{else}''
            zugeordnet ist.  Zwischen einem ``\texttt{if}'' und einem ``\texttt{else}'' dürfen nur
            solche Befehle auftreten.

            Wir bezeichnen Befehle dieser Form als \emph{geschlossene Befehle}.  Die Idee bei dieser
            Sprechweise besteht darin, dass ``\texttt{if}'' als öffnende Klammer zu interpretieren,
            während das ``\texttt{else}'' einer schließenden Klammer entspricht.  Bei einem
            geschlossenen Befehl entspricht jeder öffnenden Klammer eine schließende Klammer.
     \item Andererseits gibt es Befehle, bei denen dem letzten ``\texttt{if}'' kein
            ``\texttt{else}'' zugeordnet ist.  Solche Befehle bezeichnen wir als \emph{offene Befehle}.
            Offene Befehle dürfen nicht zwischen einem ``\texttt{if}'' und einem ``\texttt{else}''
            auftreten, denn dann müsste das ``\texttt{else}'' dem ``\texttt{if}'' des offenen
            Befehls zugeordnet werden und der offene Befehl wäre in Wahrheit geschlossen.
     \end{enumerate}
      Abbildung \ref{fig:dangling-else-correct.cup} zeigt die Umsetzung dieser Idee.
      Die syntaktische Kategorie \textsl{MatchedStmnt} beschreibt dabei die Befehle, 
      bei denen jedem ``\texttt{if}'' ein ``\texttt{else}'' zugeordnet ist, während die Kategorie 
      \textsl{UnMatchedStmnt} die restlichen Befehle erfasst.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    class Dangling;

    terminal LPAREN, RPAREN, IF, ELSE, WHILE, LBRACE, RBRACE, ASSIGN, SEMI;
    terminal NUMBER, ID;
    
    nonterminal stmnt, matchedStmnt, unmatchedStmnt, stmntList, expr;
    
    start with stmnt;

    stmnt ::= matchedStmnt
           |  unmatchedStmnt
           ;
    
    matchedStmnt ::= IF LPAREN expr RPAREN matchedStmnt ELSE matchedStmnt
                  |  WHILE LPAREN expr RPAREN matchedStmnt
                  |  LBRACE stmntList RBRACE
                  |  ID ASSIGN expr SEMI
                  ;
    
    unmatchedStmnt ::= IF LPAREN expr RPAREN stmnt
                    |  IF LPAREN expr RPAREN matchedStmnt ELSE unmatchedStmnt
                    |  WHILE LPAREN expr RPAREN unmatchedStmnt
                    ;
          
    stmntList ::= stmntList stmnt 
               |  /* epsilon */
               ;
    
    expr ::= NUMBER
          ;
    \end{Verbatim}
    \vspace*{-0.3cm}
    \caption{Eine eindeutige Grammatik für \texttt{C}-Befehle.}
    \label{fig:dangling-else-correct.cup}
\end{figure}

      Aus theoretischer Sicht ist das Umschreiben der Grammatik der sauberste Weg.  
      Aus diesem Grund haben die Entwickler der Sprache \textsl{Java} in der ersten Version der
      Spezifikation dieser Sprache \cite{gosling:96} diesen Weg auch beschritten.  
      Der Nachteil ist allerdings, dass bei diesem Vorgehen die Grammatik stark aufgebläht wird. 
      Vermutlich aus diesem Grunde findet sich in den späteren Auflagen der Sprach-Spezifikation eine
      Grammatik, bei der das \emph{Dangling-Else}-Problem wieder auftritt. 
\item Die letzte Möglichkeit um das \emph{Dangling-Else}-Problem zu lösen, besteht darin, dass
      wir ``\texttt{if}'' und ``\texttt{else}'' als Operatoren auffassen, denen wir eine Präzedenz
      zuordenen.  Abbildung \ref{fig:dangling-else-precedence.cup} zeigt die Umsetzung dieser Idee.
      \begin{enumerate}
      \item Zunächst haben wir in den Zeilen 6 und 7 die Terminale \texttt{IF} und \texttt{ELSE} als
            nicht-assoziative Operatoren deklariert, wobei \texttt{ELSE} die höhere Präzedenz
            hat.  Dadurch erreichen wir, dass ein \texttt{ELSE} auf den Stack geschoben wird,
            wenn der Parser in dem in Abbildung \ref{fig:dangling-else.output} gezeigten Zustand ist.
      \item In Zeile 9 haben wir der Regel
            \\[0.2cm]
            \hspace*{1.3cm}
            \textsl{stmnt} \texttt{::=} \texttt{IF} \texttt{LPAREN} \textsl{expr} \texttt{RPAREN} \textsl{stmnt}
            \\[0.2cm]      
            explizit mit Hilfe der nachgestellten Option
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{37}prec IF}
            \\[0.2cm]
            die Präzedenz des Operators \texttt{IF} zugewiesen.  Dies ist notwendig, weil 
            der letzte Operator, der in dieser Regel auftritt, die schließende runde Klammer
            \texttt{RPAREN} ist, der wir keine Priorität zugewiesen haben.  Der Klammer eine Priorität
            zuzuweisen wäre einerseits kontraintuitiv, andererseits problematisch, da die Klammer ja
            auch noch an anderen Stellen verwendet werden kann.  Mit Hilfe der
            \texttt{\symbol{37}prec}-Deklaration können wir einer Regel unmittelbar die Präzedenz
            eines Operators zuweisen und so das Problem umgehen.

            In dem vorliegenden Fall ist die Präzedenz des Operators \texttt{ELSE}
            höher als die Präzedenz von \texttt{IF}, so dass der Shift/Reduce-Konflikt
            dadurch aufgelöst wird, dass das Token \texttt{ELSE} auf den Stack
            geschoben wird, wodurch eine \texttt{else}-Klausel tatsächlich mit der unmittelbar davor stehenden
            \texttt{if}-Klausel verbunden wird, wie es die Definition der Sprache \texttt{C} fordert.
      \end{enumerate}

            \begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.3cm,
                  xrightmargin  = 0.3cm,
                ]
    class Dangling;

    terminal LPAREN, RPAREN, IF, ELSE, WHILE, LBRACE, RBRACE, ASSIGN, SEMI;
    terminal NUMBER, ID;
    
    nonterminal stmnt, stmntList, expr;
    
    precedence nonassoc IF;
    precedence nonassoc ELSE;
    
    start with stmnt;

    stmnt ::= IF LPAREN expr RPAREN stmnt            %prec IF
           |  IF LPAREN expr RPAREN stmnt ELSE stmnt
           |  WHILE LPAREN expr RPAREN stmnt
           |  LBRACE stmntList RBRACE
           |  ID ASSIGN expr SEMI
           ;
      
    stmntList ::= stmntList stmnt
               |  /* epsilon */
               ;
    
    expr ::= NUMBER
          ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Auflösung des Shift/Reduce-Konflikts mit Hilfe von Operator-Präzedenzen.}
\label{fig:dangling-else-precedence.cup}
\end{figure}
      
\end{enumerate}
 
Operator-Präzedenzen sind ein mächtiges Mittel um eine Grammatik zu strukturieren.  Sie
sollten allerdings mit Vorsicht eingesetzt werden, denn Sprachen wie die
Programmier-Sprache \texttt{C}, bei der es 15 verschiedene Operator-Präzendenzen gibt, überfordern
die meisten Benutzer.

\section{Auflösung von Reduce/Reduce-Konflikte}
Im Gegensatz zu Shift/Reduce-Konflikten können Reduce/Reduce-Konflikte nicht durch Operator-Präzedenzen
aufgelöst werden.  Wir diskutieren in diesem Abschnitt die Möglichkeiten, die wir haben um
Reduce/Reduce-Konflikte aufzulösen.  Wir beginnen unsere Diskussion damit, dass wir die
Reduce/Reduce-Konflikte in verschiedene Kategorien einteilen. 
\begin{enumerate}
\item \emph{Mehrdeutigkeits-Konflikte} sind Reduce/Reduce-Konflikte, die ihre Ursache in einer Mehrdeutigkeit
      der zu Grunde liegenden Grammatik haben.  Solche Konflikte weisen damit auf ein tatsächliches
      Problem der Grammatik hin und können nur dadurch gelöst werden, dass die Grammatik umgeschrieben
      wird. 
\item \emph{Look-Ahead-Konflikte} sind Reduce/Reduce-Konflikte, bei denen die Grammatik zwar
      einerseits eindeutig ist, für die aber andererseits
      ein Look-Ahead von einem Token aber nicht ausreichend ist um den Konflikt zu lösen.
\item \emph{Mysteriöse Konflikte} entstehen erst beim Übergang von den LR-Zuständen zu den LALR-Zuständen 
      durch das Zusammenfassen von Zuständen mit dem gleichen Kern.  Diese Konflikte haben ihre Ursache 
      also in der Unzulänglichkeit des LALR-Parser-Generators.
\end{enumerate}
Wir betrachten die letzten beiden Fälle nun im Detail und zeigen Wege auf, wie die Konflikte gelöst
werden können.

\subsection{Look-Ahead-Konflikte}
Ein Look-Ahead-Konflikt liegt dann vor, wenn die Grammatik zwar eindeutig ist, aber ein Look-Ahead von einem
Token nicht ausreicht um zu entscheiden,  mit welcher Regel reduziert werden soll.  Abbildung 
\ref{fig:lr-conflict.g} zeigt eine Grammatik\footnote{ 
Diese Grammatik habe ich im Netz auf der Seite von Pete Jinks unter der Adresse
\\[0.1cm]
\hspace*{1.3cm}
\href{http://www.cs.man.ac.uk/~pjj/cs212/ho/node19.html}{\texttt{http://www.cs.man.ac.uk/\symbol{126}pjj/cs212/ho/node19.html}}
\\[0.1cm]
gefunden.},
die zwar eindeutig ist, aber nicht die LR(1)-Eigenschaft hat.  

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    terminal    U, V, W, X;
    nonterminal a, b, c;

    a ::= b U V
       |  c U W
       ;
    
    b ::= X
       ;
    
    c ::= X 
       ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine eindeutige Grammatik ohne die LR(1)-Eigenschaft.}
\label{fig:lr-conflict.g}
\end{figure}


Berechnen wir die LR-Zustände dieser Grammatik,
so finden wir unter anderem den folgenden Zustand:
\\[0.2cm]
\hspace*{1.3cm}
$\{ b \rightarrow \;\squoted{X} \bullet: \squoted{U},\; c \rightarrow \;\squoted{X} \bullet: \squoted{U} \}$
\\[0.2cm]
Da die Menge der Folge-Token für beide Regeln gleich sind, haben wir hier einen Reduce/Reduce-Konflikt.
Dieser Konflikt hat seine Ursache darin, dass der Parser mit einem Look-Ahead von nur einem Token nicht
entscheiden kann, ob ein $\quoted{X}$ als ein $b$ oder als ein $c$ zu interpretieren ist, denn dies
entscheidet sich erst, wenn das auf $\quoted{U}$ folgende Zeichen gelesen wird:  Handelt es sich hierbei
um ein $\quoted{V}$, so wird insgesamt die Regel
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow b\; \squoted{U} \squoted{V}$
\\[0.2cm]
verwendet werden und folglich ist das $\quoted{X}$ als ein $b$ zu interpretieren. Ist das zweite Token
hinter dem $\quoted{X}$ hingegen ein  $\quoted{W}$, so ist die zu verwendende Regel
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow c \;\squoted{U} \squoted{W}$
\\[0.2cm]
und folglich ist das $\quoted{X}$ als  $c$ zu lesen.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    a : b 'V'
      | c 'W'
      ;
    b : 'X' 'U'
      ;
    c : 'X' 'U'
      ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine zu der in Abbildung \ref{fig:lr-conflict.g}   äquivalente LR(1)-Grammatik.}
\label{fig:lr-conflict-resolved.g}
\end{figure}

Das Problem bei dieser Grammatik ist, dass sie versucht, abhängig vom Kontext ein $\squoted{X}$ wahlweise
als ein $b$ oder als ein $c$ zu interpretieren.  Es ist offensichtlich, wie das Problem gelöst werden
kann:  Wenn der Kontext ``\texttt{U}'', der sowohl auf $b$ als auch auf $c$ folgt, mit in
die Regeln für $B$ und $C$ aufgenommen wird, dann verschwindet der Konflikt.  Abbildung
\ref{fig:lr-conflict-resolved.g} zeigt die modifizierte Grammatik.

\subsection{Mysteriöse Reduce/Reduce-Konflikte}
Wir sprechen dann von einem \emph{mysteriösen Reduce/Reduce-Konflikt}, wenn die gegebene Grammatik eine
LR(1)-Grammatik ist, sich aber beim Übergang von LR-Zuständen zu LALR-Zuständen Reduce/Reduce-Konflikte
ergeben.  Die in Abbildung \ref{fig:mysterious.cup} gezeigte Grammatik habe ich dem \textsl{Bison}-Handbuch
entnommen. (\textsl{Bison} ist ein LALR-Parser-Generator für die Sprachen \texttt{C} und
\texttt{C++}.  Er kann mittlerweile auch Parser in der Sprache \textsl{Java} erzeugen, allerdings
ist dieses Feature bisher noch als experimentell deklariert.)

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    terminal    ID, COMMA, COLON;
    nonterminal def, param_spec, return_spec, type, name_list, name;
    
    def   
        ::= param_spec return_spec COMMA
         ;
    param_spec
        ::= type
         |  name_list COLON type
         ;    
    return_spec
        ::= type
         |  name COLON type
         ;
    type  
        ::= ID
         ;    
    name
        ::= ID
         ;
    name_list
        ::= name
         |  name COMMA name_list
         ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine \textsc{Cup}-Grammatik mit einem mysteriösen Reduce/Reduce-Konflikt.}
\label{fig:mysterious.cup}
\end{figure}
\vspace*{0.3cm}

Übersetzen wir diese Grammatik mit \textsc{Cup}, so erhalten wir unter anderem den folgenden Zustand:
\begin{verbatim}
    lalr_state [1]: {
      [name ::= ID (*) , {COMMA COLON }]
      [type ::= ID (*) , {ID COMMA }]
    }
\end{verbatim}
Da in beiden Mengen von Folgetoken das Token \texttt{COMMA} auftritt, gibt es hier offensichtlich einen
Reduce/Reduce-Konflikt.   Um diesen Konflikt besser zu verstehen, berechnen wir zunächst die Zustände
eines kanonischen LR-Parsers für diese Grammatik.
Wir erhalten dann eine Menge von Zuständen, von denen die für den späteren Konflikt ursächlichen 
Zuständen in Abbildung \ref{fig:mysterious.txt} gezeigt sind.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    s0 = { S -> <*> def: [$],
           def -> <*> param_spec return_spec ',': [$],
           name -> <*> ID: [',', ':'],
           name_list -> <*> name: [':'],
           name_list -> <*> name ',' name_list: [':'],
           param_spec -> <*> name_list ':' type: [ID],
           param_spec -> <*> type: [ID],
           type -> <*> ID: [ID]
         }
    s2 = { def -> param_spec <*> return_spec ',': [$],
           name -> <*> ID: [':'],
           return_spec -> <*> name ':' type: [','],
           return_spec -> <*> type: [','],
           type -> <*> ID: [',']
         }
    s7 = { name -> ID <*>: [',', ':'],
           type -> ID <*>: [ID]
         }
    s8 = { name -> ID <*>: [':'],
           type -> ID <*>: [',']
         }

\end{Verbatim}
\vspace*{-0.3cm}
\caption{LR-Zustände der in Abbildung \ref{fig:mysterious.cup} gezeigten Grammatik.}
\label{fig:mysterious.txt}
\end{figure} %\$

Analysieren wir die Zustände, so stellen wir fest, dass beim Übergang von LR-Zuständen zu den
LALR-Zuständen die beiden Zustände $s_7$ und $s_8$ zu einem Zustand zusammengefasst werden, denn diese
beiden Zustände haben den selben Kern.  Bei der Zusammenfassung entsteht der Zustand, der von
\textsc{Cup} als ``\texttt{lalr\_state [1]}'' bezeichnet hat.  Die Zustände $s_7$ und $s_8$ selber haben
noch keinen Konflikt, weil dort die Mengen der Folgetoken disjunkt sind.  Der Konflikt tritt erst durch
die Vereinigung dieser beiden Mengen auf, denn dadurch ist das Token ``$\texttt{,}$'' als Folgetoken für
beide in dem Zustand enthaltenen Regeln zulässig.   Um den Konflikt aufzulösen müssen wir verhindern, dass
die beiden Zustände $s_7$ und $s_8$ zusammengefasst werden.  Dazu analysieren wir zunächst, wo diese
Zustände herkommen.
\begin{enumerate}
\item Den Zustand $s_7$ erhalten wir, wenn wir im Zustand $s_2$ das Token \texttt{ID} lesen, denn
      es gilt 
      \\[0.2cm]
      \hspace*{1.3cm}
      $s_7 = \textsl{goto}(s_2, \mathtt{ID})$.
\item Der Zustand $s_8$ entsteht, wenn das Token \texttt{ID} im Zustand $s_0$ gelesen wird, wir haben
      \\[0.2cm]
      \hspace*{1.3cm}
      $s_8 = \textsl{goto}(s_0, \mathtt{ID})$.
\end{enumerate}
Die Idee zur Auflösung des Konflikts ist, dass wir den Zustand $s_2$ so ändern, dass die Kerne von
$\textsl{goto}(s_2, \mathtt{ID})$ und $\textsl{goto}(s_0, \mathtt{ID})$ unterschiedlich werden.  
Die erweiterten markierten Regeln in dem Zustand $s_2$, die letztlich für den Konflikt verantwortlich
sind, sind die Grammatik-Regeln für die syntaktische Variable \textsl{return\_spec}.
Wir ändern diese Regeln nun wie in Abbildung \ref{fig:myst-solved.g} ab, indem wir eine zusätzliche
Grammatik-Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{return\_spec} \rightarrow \mathtt{ID}\;\, \mathtt{BOGUS}$
\\[0.2cm]
einführen.  Wenn das Terminal \texttt{BOGUS} nie vom Scanner erzeugt werden kann, dann ändert sich durch
die Hinzunahme dieser Regel die von der Grammatik erzeugte Sprache nicht.  Allerdings ändern sich nun die
LR-Zustände.  Abbildung \ref{fig:myst-solved.txt} zeigt, wie sich die entsprechenden Zustände ändern.
Insbesondere sehen wir, dass der Zustand $s_8$ nun eine weitere markierte Regel enthält, zu der es in dem
Zustand $s_7$ kein äquivalent gibt.  Die Konsequenz ist, dass diese Zustände in einem
LALR-Parser-Generator nicht mehr zusammengefasst werden.  Dadurch gibt es dann auch keinen Konflikt mehr.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    def : param_spec return_spec ','
        ;    
    param_spec
        : type
        |  name_list ':' type
        ;
    return_spec
        : type
        | name ':' type
        | ID BOGUS      // this never happens
        ;
    type: ID
        ;
    name: ID
        ;
    name_list
        : name
        | name ',' name_list
        ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Auflösung des mysteriösen Reduce/Reduce-Konflikts.}
\label{fig:myst-solved.g}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    s0 = { S -> <*> def: [$],
           def -> <*> param_spec return_spec ',': [$],
           name -> <*> ID: [',', ':'],
           name_list -> <*> name: [':'],
           name_list -> <*> name ',' name_list: [':'],
           param_spec -> <*> name_list ':' type: [ID],
           param_spec -> <*> type: [ID],
           type -> <*> ID: [ID]
         }    
    s2 = { def -> param_spec <*> return_spec ',': [$],
           name -> <*> ID: [':'],
           return_spec -> <*> ID BOGUS: [','],
           return_spec -> <*> name ':' type: [','],
           return_spec -> <*> type: [','],
           type -> <*> ID: [',']
         }
    s7 = { name -> ID <*>: [',', ':'],
           type -> ID <*>: [ID]
         }    
    s8 = { name -> ID <*>: [':'],
           return_spec -> ID <*> BOGUS: [','],
           type -> ID <*>: [',']
         }
\end{Verbatim}
\vspace*{-0.3cm} %\$
\caption{Einige Zustände der in Abbildung \ref{fig:myst-solved.g} gezeigten Grammatik.}
\label{fig:myst-solved.txt}
\end{figure}

\vspace*{\fill}
\pagebreak

\vspace*{\fill}
\pagebreak


\exercise
Nachstehend sehen Sie Regeln für eine Grammatik, die Listen von Zahlen beschreibt:
\begin{eqnarray*}
  \textsl{List} & \rightarrow & \textsc{Number} \quoted{,} \textsl{List} \\
                & \mid        & \textsc{Number}                         
\end{eqnarray*}
Diese Grammatik ist rechts-rekursiv.  Alternativ ist auch eine links-rekursive Grammatik möglich:
\begin{eqnarray*}
  \textsl{List} & \rightarrow & \textsl{List} \quoted{,} \textsc{Number} \\
                & \mid        & \textsc{Number}                         
\end{eqnarray*}
Überlegen Sie, welche dieser beiden Grammatiken effizienter ist, wenn Sie aus diesen Regeln mit einem
LALR-Parser-Generator einen Parser erzeugen wollen.  Berechnen Sie dazu für beide Fälle die Zustände
und Aktionen und untersuchen Sie, wie eine Liste von natürlichen Zahlen der Form
\\[0.2cm]
\hspace*{1.3cm}
$x_1$, $x_2$, $\cdots$, $x_{n-1}$, $x_n$
\\[0.2cm]
in den beiden Fällen geparst wird.  Geben Sie insbesondere an, wie der Stack des Shift/Reduce-Parsers
aussieht, wenn die Teilliste 
\\[0.2cm]
\hspace*{1.3cm}
$x_1$, $x_2$, $\cdots$, $x_{k-1}$, $x_k$ \quad mit $k \leq n$ 
\\[0.2cm]
gelesen worden ist.  \eox
\pagebreak


\section{Auflösung von Shift/Reduce-Konflikten}
Es gibt im wesentlichen zwei Arten von Shift/Reduce-Konflikten:
\begin{enumerate}
\item Konflikte, die auf eine Mehrdeutigkeit der Grammatik zurückzuführen sind.

      Solche Mehrdeutigkeits-Konflikte hatten wir beispielsweise in der Grammatik für arithmetische
      Ausdrücke, die in Abbildung \ref{fig:shift-reduce-conflict.grammar} auf Seite
      \pageref{fig:shift-reduce-conflict.grammar} gezeigt ist, diskutiert.  In dem Beispiel waren
      diese Konflikte darauf zurückzuführen, dass durch die Grammatik keine Präzedenzen für die
      arithmetischen Operatoren festgelegt wurde, so dass am Ende nicht klar war, ob ein Ausdruck
      der Form ``\texttt{1+2*3}'' als ``\texttt{1+(2*3)}'' oder als ``\texttt{(1+2)*3}'' zu
      interpretieren ist.

      Wir haben bereits früher in Abschnitt \ref{section:operator-precedence} besprochen, wie solche
      Konflikte durch die Spezifikation von Operator-Präzedenzen aufgelöst werden können.
\item Konflikte, die entstehen, weil ein Look-Ahead von einem Token nicht ausreichend ist um zu
      entscheiden, ob mit einer Regel reduziert werden soll.  Solche \emph{Look-Ahead}-Konflikte
      werden wir in diesem Abschnitt diskutieren.
\end{enumerate}
Als Beispiel für einen Look-Ahead-Konflikt betrachten wir die in Abbildung \ref{fig:lambda.g}
gezeigte Grammatik.  Diese Grammatik beschreibt drei Arten von Ausdrücken:
\begin{enumerate}
\item $\lambda$-Ausdrücke haben syntaktisch die Form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[$x_1$, $\cdots$, $x_n$] |-> $e$}.
      \\[0.2cm]
      Ein solcher Ausdruck steht für eine Funktion, die $n$ Argumente $x_1$, $\cdots$, $x_n$
      verarbeitet und als Ergebnis den Ausdruck $e$ zurück liefert, wobei der Ausdruck $e$ im
      Allgemeinen von den Parametern $x_1$, $\cdots$, $x_n$ abhängen wird.   Ein konkretes Beispiel
      wäre etwa der $\lambda$-Ausdruck
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[x, y] |-> [x, y, x]}.
\item Zusätzlich sind als Ausdrücke Variablen-Namen zugelassen.
\item Außerdem sind auch Listen von Ausdrücken möglich, wobei diese Listen in eckigen Klammern
      eingefasst werden.  Diese Listen können dabei beliebig geschachtelt sein.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    terminal MAPSTO, LBRACKET, RBRACKET, COMMA, IDENTIFIER;
    
    nonterminal expr, exprList, lambdaDefinition, identifierList;
    
    expr ::= lambdaDefinition
          |  IDENTIFIER  
          |  LBRACKET exprList RBRACKET
          ;
    
    lambdaDefinition
         ::= LBRACKET identifierList RBRACKET MAPSTO expr
          ;
    
    identifierList
         ::= IDENTIFIER COMMA identifierList 
          |  IDENTIFIER
          ;
    
    exprList
         ::= expr COMMA exprList
          |  expr
          ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine \textsc{Cup}-Grammatik für $\lambda$-Ausdrücke.}
\label{fig:lambda.g}
\end{figure}

Versuchen wir mit \textsc{Cup} einen Parser für diese Grammatik zu erzeugen, so erhalten wir
verschiedene Shift/Reduce-Konflikte.  Diese Konflikte entstehen in dem Zustand Nummer 6, der in
Abbildung \ref{fig:lambda.g:state6} gezeigt ist.  Da auf eine \textsl{expr} ein ``\texttt{,}''
folgen kann, dieses aber in dem Zustand gleichzeitig auch auf den Stack geschoben werden kann, ist
nicht klar, ob mit der Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{expr} \rightarrow \mathtt{IDENTIFIER}$
\\[0.2cm]
reduziert werden darf, wenn das Look-Ahead-Token ein Komma ist.  Um zu entscheiden, ob der Parser
versucht eine Liste von \texttt{IDENTIFIER}n zu parsen, müsste der Parser bis zu dem Token
\texttt{MAPSTO} schauen können.  Wenn später ein solches Token noch kommt, dann würde der Parser im
Zustand 6 versuchen eine \textsl{identifierList} zu parsen und das Komma sollte auf den Stack
geschoben werden.  Andernfalls könnte mit der Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{expr} \rightarrow \mathtt{IDENTIFIER}$
\\[0.2cm]
reduziert werden. Leider lässt ein LR-Parser-Generator nicht zu, dass wir den noch ungelesenen Teil
der Eingabe inspizieren.  Wir müssen daher eine andere Lösung suchen.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    lalr_state [6]: {
      [identifierList ::= IDENTIFIER (*) COMMA identifierList , {RBRACKET }]
      [expr ::= IDENTIFIER (*) , {RBRACKET COMMA }]
      [identifierList ::= IDENTIFIER (*) , {RBRACKET }]
    }
\end{Verbatim}
 \vspace*{-0.3cm}
\caption{Der Zustand mit der Nummer 6 zu der Grammatik aus Abbildung \ref{fig:lambda.g}}
\label{fig:lambda.g:state6}
\end{figure}

Wir können den Shift/Reduce-Konflikt lösen, indem wir die Grammatik wie in Abbildung
\ref{fig:lambda-generalized.cup} gezeigt \textbf{verallgemeinern}.  Diese Grammatik lässt auch
Ausdrücke zu, bei denen in der Argument-Liste nicht nur Variablen-Namen enthält, sondern Ausdrücke
beliebiger Komplexität.  Damit beschreibt diese Grammatik eine Sprache, die eigentlich zu allgemein
ist.  Es ist aber ein leichtes, später den resultierenden Syntax-Baum drauf hin zu untersuchen, ob
in der Parameter-Liste tatsächlich nur Variablen stehen oder nicht.  Daher bietet eine solche
Verallgemeinerung der Grammatik eine praktische Möglichkeit um Shift/Reduce-Konflikte zu lösen.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm, 
                  xrightmargin  = 0.8cm,
                ]
    terminal    MAPSTO, LBRACKET, RBRACKET, COMMA, IDENTIFIER;
    
    nonterminal expr, exprList, lambdaDefinition;
    
    expr ::= lambdaDefinition
          |  IDENTIFIER  
          |  LBRACKET exprList RBRACKET
          ;
    
    lambdaDefinition
         ::= LBRACKET exprList RBRACKET MAPSTO expr
          ;
    
    exprList
         ::= expr COMMA exprList
          |  expr
          ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die verallgemeinerte Grammatik für $\lambda$-Ausdrücke.}
\label{fig:lambda-generalized.cup}
\end{figure}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
