\chapter{The Scanner Generator \textsl{JFlex}}
A  \emph{scanner} is a tool that splits a given string into a list of \emph{token}, where a token is
just a group of consecutive characters that belong together logically.  An example will clarify this.  
The input for a \texttt{C}-compiler is a long \textsc{Ascii}-string such that can be interpreted as a
valid \texttt{C} program.  In order to translate this string into machine language, the
\texttt{C}-compiler first groups the different characters into tokens.  In the case of a \texttt{C}
program, the compiler generates the following tokens:
\begin{enumerate}
\item \emph{Keywords}, a.k.a.~reserved words like ``\texttt{if}'', ``\texttt{while}'', or ``\texttt{case}''.
\item \emph{Operator symbols} like ``\texttt{+}'', ``\texttt{+=}'', ``\texttt{<}'', or
      ``\texttt{<=}''. 
\item \emph{Parentheses} like ``\texttt{(}'', ``\texttt{[}'', and ``\texttt{\{}'' and the
      corresponding closing symbols.
\item \emph{Constants}.  The language \texttt{C} distinguishes between three different kinds of constants:
      \begin{enumerate}
      \item Numbers, for example the integer ``\texttt{123}'' or the floating point number ``\texttt{1.23e2}''.
      \item Strings, which are enclosed in double.  For example,
            ``\texttt{\symbol{34}hallo\symbol{34}}'' is a string constant.  Note that the character
            ``\texttt{\symbol{34}}'' is part of the string constant, while the opening and closing
            quotes surrounding the string constant have been used to separate the string constant
            from the surrounding text. 
      \item Single letters that are enclosed in single quotes as in
            ``\texttt{\symbol{39}a\symbol{39}}''.
      \end{enumerate}
\item \emph{Names} that can act as variable names, function names, or type names.
\item \emph{Comments}, which come in two flavors:  \emph{Single line comments} start with the string
      ``\texttt{//}'' and extend to the end of the line, while \emph{multi line comments} start with
      the string ``\texttt{/*}'' and are ended by ``\texttt{*/}''.
\item So called \emph{white space characters}.  For example the blank, tabulators, line breaks, and
      carriage returns are white space symbols.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    /* Hello World program */
    #include<stdio.h>
    
    int main() {
        printf("Hello World!\n");
        return 1;
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A simple \texttt{C} program.}
\label{fig:hello-world.c}
\end{figure}

To make things more precise, Figure \ref{fig:hello-world.c} contains a \texttt{C} program that
prints the string ``\texttt{Hello World!}'' followed by a newline character.  The scanner would
transform this program into the following list of tokens:
\begin{verbatim}
   [ "/* Hello World program */", "#", "include", "<", "stdio.h", ">",
     "int", "main", "(", ")", "{", "printf", "(", "Hello World!\n", ")", ";"
     "return", "1", ";", "}"
   ]
\end{verbatim}

\textsl{JFlex}\/ \cite{klein:2009} is a so called  \emph{scanner generator}, i.e.~\textsl{JFlex} is
a tool that takes as input the specification of the lexical structure of the tokens and that
generates a scanner from this specification.  Usually, we specify the lexical structure of the
tokens via regular expressions.
You can find \textsl{JFlex} at 
\\[0.2cm]
\hspace*{1.3cm}
\href{http://jflex.de}{\texttt{http://jflex.de}}.
\\[0.2cm]
As \textsl{JFlex} is implemented in  \textsl{Java} it can be used on all platforms that support
\textsl{Java}.    In this lecture, we will use \textsl{Java} version \texttt{1.6.1}.

The next section discusses the structure of a  \textsl{JFlex} input file and we will show how
\textsl{JFlex} is used.  Next, we discuss the syntax of regular expressions as they are used in
\textsl{JFlex}.  We finish the chapter with an example that shows how we can use \textsl{JFlex} to
evaluate the results of an exam.

The scanner generated by \textsl{JFlex}\/ are \textsl{Java} programs.  For the languages \texttt{C}
and \texttt{C++} there exist two similar programs that are called 
\href{http://en.wikipedia.org/wiki/Lex_(software)}{\textsl{Lex}}
\cite{lesk:1975} and \href{http://flex.sourceforge.net}{\textsl{Flex}} \cite{nicol93}, which is
essentially just a faster version of \textsl{Lex}.


\section{Structure of a \textsl{JFlex} Specification}
A  \textsl{JFlex} scanner specification is made up of three parts that are separated by the string
``\texttt{\%\%}''.
This separator string has to be positioned at the start of a line.
\begin{enumerate}
\item The first part is the  \emph{user code}.  This part might contain a
      \texttt{package} declaration and \texttt{import} directives.  Both the package declaration and
      the import directives are copied verbatim into the \textsl{Java} program that is generated by
      \textsl{JFlex}.  Furthermore, the user code may contain the definition of local \textsl{Java}
      classes.  However, the use of local classes is usually not recommended.

      Figure \ref{fig:count.jflex} on pages \pageref{fig:count.jflex} gives an example of the
      \textsl{JFlex} specification of a scanner that has the purpose of recognizing numbers that are
      hidden in a text.  These numbers are then added.
      In this case the user code consists only of the \texttt{package} declaration in line 1.
\item The second part contains options and declarations.  This part sets various options and,
      furthermore, may declare member variables and methods of the generated scanner class.

      In Figure \ref{fig:count.jflex} this part starts in line  4 and ends in line 14.
\item The third part defines the \emph{scanner rules}.  A scanner rule is a pair of a regular
      expression and \textsl{Java} code which is executed if the regular expression is found.

      In Figure \ref{fig:count.jflex} this part starts in line 18 and ends with line 20. 
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    package count;
    %%
    
    %class Count
    %standalone
    %unicode
    
    %{
        int mCount = 0;
    %}
    
    %eof{
        System.out.println("Total: " + mCount); 
    %eof}
    
    %%

    0[0-9]+        { /* skip strings like 007 */      }
    0|[1-9][0-9]*  { mCount += new Integer(yytext()); }
    .|\R           { /* skip anything else */         }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine einfache Scanner-Spezifikation für \textsl{JFlex}}
\label{fig:count.jflex}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    Here are 33 apples and 5 pears.  Furthermore, here are
    8 bananas and 3 peaches.  James Bond is agent 007.  
    How many pieces of fruit does this text contain?
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine Eingabe-Datei für den in Abbildung \ref{fig:count.jflex} spezifizierten Scanner.}
\label{fig:input.txt}
\end{figure}

We proceed to discuss the \textsl{JFlex} specification shown in Figure \ref{fig:count.jflex}.
The purpose of the scanner that is generated from this \textsl{JFlex} specification is to process 
a string that might contain numbers.  The scanner finds these numbers and adds them up.
For example, a typical string processed by this scanner might be the file shown in 
Figure \ref{fig:input.txt} on page \pageref{fig:input.txt}.  Here our scanner would find the
substrings ``\texttt{33}'', ``\texttt{5}'', ``\texttt{8}'', and ``\texttt{3}'', convert these
strings into numbers, and finally add these numbers.  The scanner would
realize that the string ``\texttt{007}'' is not a number since it starts with a leading zero.

We proceed to discuss the scanner specification shown in \ref{fig:count.jflex} line by line.
\begin{enumerate}
\item Line 1 specifies that the generated scanner is part of the package \texttt{count}.
      If the scanner were a bit more complex we would have to use some \texttt{import} directives
      here as well.  However, as this is example is rather simple, we do not need to import
      any packages.
\item Line 4 specifies that the scanner is part of a class that has the name \texttt{Count}.
\item Line 5 specifies that the scanner is not part of a parser but rather operates on its own.
      Hence,  \textsl{JFlex} will generate a method with the name \texttt{main} as part of the
      class \texttt{Count}.  This method will scan all files that are provided as arguments in the
      command line when the scanner is called.

      A scanner that is equipped with a  $\texttt{main}$ method is called a 
      \emph{stand alone scanner}.  Often, a scanner is used together with a parser.  In that case,
      the \texttt{main} method is not part of the scanner but rather resides in the parser.  We will
      discuss these types of scanners in Chapter \ref{chapter:cup} when we discuss the parser generator 
      \href{http://www2.cs.tum.edu/projects/cup/}{cup}.
\item Line 6 specifies that the generated scanner assumes that strings are encoded using
      \href{https://en.wikipedia.org/wiki/Unicode}{\emph{unicode}}.  This option should always be
      used if the scanner is intended  to process text files.
\item In line 8 to line 10 we declare \texttt{mCount} as a member variable of the scanner that is
      generated.  In order to do this, we use the keywords ``\texttt{\%\{}'' and ``\texttt{\%\}}''.
      Note that these keywords have to be located at the beginning of a line.  Having declared and
      initialized the variable \texttt{mCount} enables us to use this variable in the actions.  This
      is discussed later.

      If the scanner was more complicated, we could also have defined methods inside the keywords
      ``\texttt{\%\{}'' and ``\texttt{\%\}}''.  
      The code for this methods would then be copied verbatim into the generated scanner class.
\item In line 12 to line 14 we specify code that is to be executed once the end of the file to be
      scanned is reached.  This code has to be enclosed using the keywords
      ``\texttt{\%eof\{}'' and ``\texttt{\%eof\}}''.  
      Again, in order to be recognized, these keywords have to be located at the beginning of a line.

      Specifying code that is executed once all input has been read is typically only done in a 
      stand alone scanner.  In this example, the value of the variable \texttt{mCount} is printed,
      since this variable contains the sum of all numbers that have been found.
\item The lines 18 to 20 contain the rules of our scanner.  A scanner rule has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \textsl{regexp} $\quoted{\{}$ \textsl{action} $\quoted{\}}$
      \\[0.2cm]
      Here, \textsl{regexp} is a regular expression, while \textsl{action} is a fragment of 
      \textsl{Java} code.  This code is executed once text is found that matches the given regular
      expression.
      \begin{enumerate}
      \item In line 18 the regular expression  ``\texttt{0[0-9]+}'' matches any string that starts
            with the digit ``\texttt{0}'', which has to be followed by more digits.
            Here, the regular expression ``\texttt{[0-9]}'' denotes a so called \emph{range}, which
            is the range of all characters from ``\texttt{0}'' to ``\texttt{9}''.
            This range is followed by the postfix operator ``\texttt{+}'', which is similar to the
            Kleene operator ``\texttt{*}''.  The difference between the operator ``\texttt{+}''
            and the operator ``\texttt{*}'' is that the operator ``\texttt{+}'' specifies that at
            least one digit has to occur.  Hence, an expression of the form
            \\[0.2cm]
            \hspace*{1.3cm}
            $r\mathtt{+}$
            \\[0.2cm]
            specifies that $r$ occurs any positive number of times, while
            \\[0.2cm]
            \hspace*{1.3cm}
            $r\mathtt{*}$
            \\[0.2cm]
            specifies that $r$ occurs any number of times, where ``any number of times'' includes
            zero times. We will discuss how \textsl{JFlex} defines regular expressions later in more detail.
 
            In the case of line 18, the action, which is the string enclosed in curly braces, is
            empty because it contains nothing but a comment.  Hence, the sole purpose of line 18 is
            to recognize strings of the form ``007'' and to prevent these strings from being
            processed in line 19.  The point here is that the rules are tried in the order they are
            specified and once a string is scanned with one rule, the string is removed so that it
            is not processed by any of the following rules.

      \item In line 19 the regular expression  ``\texttt{0|[1-9][0-9]*}'' is used to recognize a
            proper natural number.  The corresponding string is returned by the function
            $\texttt{yytext}()$.  This string is then converted into an integer using the
            constructor of the class \texttt{Integer}.  Finally, this integer is added to the
            variable \texttt{mCount} which keeps the running total of all integers found.
      \item In line 20 the regular expression  ``\texttt{.|\symbol{92}R}'' specifies any single character.
            The regular expression ``\texttt{.}'' specifies any character that is different from a
            unicode line break, while ``\texttt{\symbol{92}R}'' specifies any unicode line break.
            Hence,  ``\texttt{\symbol{92}R}'' specifies characters like
            ``\texttt{\symbol{92}n}'' (line feed) or ``\texttt{\symbol{92}r}'' (carriage return),
            but also the unicode characters
            \\[0.2cm]
            \hspace*{1.3cm}
            ``\texttt{\symbol{92}u2028}'',
            ``\texttt{\symbol{92}u2029}'',
            ``\texttt{\symbol{92}u000B}'',
            ``\texttt{\symbol{92}u000C}'' and
            ``\texttt{\symbol{92}u0085}''.
            \\[0.2cm]
            In the regular expression  ``\texttt{.|\symbol{92}R}'' the operator ``\texttt{|}'' denotes the
            choice between two alternatives.  In the previous chapter we had used the  operator ``$+$''
            for this purpose, but the syntax of regular expressions in  \textsl{JFlex} is quite different
            from the syntax we have presented in the previous chapter.  We will discuss the way regular
            expressions are specified in \textsl{JFlex} in the following section.

            In line 20, the action is again empty because it contains just a comment.
            The effect is therefore that all characters that are not matched by the previous rules
            in line 18 or line 19 are just skipped.  This rule is necessary because by default any
            character that is not matched by any of the rules is printed to standard output.
      \end{enumerate}
\end{enumerate}
In order to generate a scanner from the \textsl{JFlex} specification shown in Figure
\ref{fig:count.jflex} we have to use the  command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{jflex -d count count.jflex}
\\[0.2cm]
which will generate the file \texttt{Count.java}.  The option  ``\texttt{-d}'' specifies that this
file is to be generated in the directory  \texttt{count}.  This is necessary as the scanner contains
the package declaration 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{package count;}.
\\[0.2cm] 
The generated file \texttt{Count.java} is then translated using the following command:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{javac count/Count.java}
\\[0.2cm]
The scanner is then executed using the command:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{java count.Count input.txt}
\\[0.2cm]
Here,  \texttt{input.txt} is the name of the file that is to be scanned.   For the file shown in Figure
\ref{fig:input.txt} we get the result
\\[0.2cm]
\hspace*{1.3cm}
\texttt{Total: 49}.
\\[0.2cm]
In order that we don't have to repeat all of the commands given above it is advisable to use a so
called \href{http://en.wikipedia.org/wiki/Make_(software)}{\textsl{Makefile}}.
Figure \ref{fig:count-makefile} shows the file ``\texttt{Makefile}''.  This files contains rules for
building and running the scanner automatically.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    run: count/Count.class input.txt
    	java count/Count input.txt
    
    count/Count.class: count/Count.java
    	javac count/Count.java
    
    count/Count.java: count.jflex
	jflex -d count count.jflex
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ein Makefile zur Erstellung des Scanners.}
\label{fig:count-makefile}
\end{figure}

\begin{enumerate}
\item The first line of the file \texttt{Makefile} defines the \emph{goal} that is to be
      constructed.  In this case, we have named the goal ``\texttt{run}''.  After the 
      goal, the first line lists the \emph{dependencies}.  The dependencies are those
      tasks that need to be completed before the goal can be achieved.
      In this case there are two dependencies and these dependencies are file names: First,
      there is the file \texttt{Count.class}, which is located in the directory \texttt{count}, and
      second there is the file \texttt{input.txt}.  These two files have to be constructed before
      the main goal can be constructed.  Note that the goal and its dependencies have to be
      separated by the character ``\texttt{:}''.

      The second line consists of the command that is executed to reach the goal.  In this case,
      the command executes feeds the file \texttt{input.txt} to the generated scanner.  The
      combination of the first two lines is called a \emph{make rule}.  Every make rule consists of
      an \emph{header line}, which is not indented, and a \emph{body}.  The header specifies the
      goal and its dependencies, while the body contains one or more lines of commands that are
      executed in order to achieve the given goal.  These command lines have to be indented using tab characters.

      \textbf{Warning}:  It is very important that the lines of the body are indented using a tabulator
      character!  If they are indented using blanks instead, the make file would not work.
      This syntactic feature has caused despair to many students, since in the editor,
      a number of blanks can look exactly the same as a tab character.
\item Line 4 specifies how the file \texttt{Count.class} in the directory \texttt{count} is to be
      generated.  In this case, in order to generate the file \texttt{Count.class}, the file
      \texttt{Count.java} is required as a dependency.  Once this dependency is satisfied,
      the file \texttt{Count.java} is constructed using the \textsl{Java} compiler \texttt{javac}.
\item Finally, the rule in line 7 and 8 shows that in order to generate the file
      \texttt{Count.java}, the file \texttt{count.jflex} is required.  Furthermore, is specifies
      that the scanner in file \texttt{Count.java} can be constructed by calling \texttt{jflex}.
\end{enumerate}
Once we have the file \texttt{Makefile}, a single command is sufficient to generate the scanner and
to execute it.  Just typing
\\[0.2cm]
\hspace*{1.3cm}
\texttt{make}
\\[0.2cm] 
in the command line generates the scanner and executes it.  Furthermore, the command \texttt{make}
takes care to perform only the steps that are necessary.  For example, if we had already generated
the scanner in the file \texttt{Count.class}, then \texttt{make} would only execute the command
\\
\hspace*{1.3cm}
\texttt{java count/Count input.txt}
\\[0.2cm]
and not generate the scanner a second time.  However, if \texttt{make} detects that the file
\texttt{count.jflex} has been changed after the file \texttt{count/Count.java} had been generated,
then \texttt{make} knows that the scanner has to be rebuild from scratch.

\remarkEng
While all variants of the \textsl{Unix} operating system are equipped with the command \texttt{make}
from start, the operating system \textsl{Windows} does not provide \texttt{make} by default.
However, on a \textsl{Windows} operating system you can install \texttt{make} from
\\[0.2cm]
\hspace*{1.3cm}
\href{http://gnuwin32.sourceforge.net/packages/make.htm}{\texttt{http://gnuwin32.sourceforge.net/packages/make.htm}}.
\\[0.2cm]
While this is really not necessary for the \textsl{JFlex} examples, having \texttt{make} available
will save you some typing as this lecture proceeds.

\homeworkEng
Install \textsl{JFlex} and make sure that the examples that have been presented in this section of
the lecture notes work with your installation.  If you are working on a \textsl{Windows} operating
system, you should also install \texttt{make}. 

\section{The syntax of Regular Expressions in \textsl{JFlex}}
In the previous chapter we have defined regular expressions using only a minimal amount of syntax. 
Using as little syntax as possible is beneficial for our upcoming theoretical investigations of
regular expression in the next chapter where we show that regular expressions can be implemented
using finite state machines.  However, for practical applications it is useful to considerably
enrich the syntax of regular expressions that we have seen so far.
For this reason, \textsl{JFlex}\/ provides a number of abbreviations that enable us to denote
complex regular expressions in a more compact form.  The regular expressions of \texttt{JFlex} are
based on the \textsc{Ascii} alphabet.  We have to distinguish between characters, that can be used
as operators, and the remaining characters.   The set of \textsl{OpSyms} of operator symbols is
defined as follows:
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{OpSyms} := \{$ ``\texttt{.}'', 
``\texttt{*}'', 
``\texttt{+}'', 
``\texttt{?}'', 
``\texttt{!}'', 
``\texttt{\symbol{126}}'', 
``\texttt{|}'', 
``\texttt{(}'', 
``\texttt{)}'', 
``\texttt{[}'', 
``\texttt{]}'', 
``\texttt{\{}'', 
``\texttt{\}}'', 
\\[0.2cm]
\hspace*{3.4cm}
``\texttt{<}'', 
``\texttt{>}'',
``\texttt{/}'', 
``\texttt{\symbol{92}}'', 
``\texttt{\symbol{94}}'', 
``\texttt{\symbol{36}}'', 
``\texttt{\symbol{34}}'' $\}$
\\[0.2cm]
Furthermore,  $\textsl{WsSym}$ denotes the set of all \textsc{Ascii} characters that represent white
space.  Hence this set contains the blank space, the line break, the carriage return, the horizontal
tabulator, and the vertical tabulator.
Using these two sets we can now define the set $\textsl{Regexp}\/$ which is the set of all regular
expressions supported by \textsl{JFlex}.  This set is defined inductively:
\begin{enumerate}
\item $c \in \textsl{Regexp}$ \quad provided $c \in \Sigma_{\textsc{\scriptsize Ascii}}
       \backslash \bigl(\textsl{OpSyms} \cup \textsl{WsSyms}\bigr)$

      All characters $c$  from the \textsc{Ascii} alphabet that are neither operator symbols nor
      white space symbols are regular expressions that match the corresponding character $c$.
\item ``\texttt{.}''$\in \textsl{Regexp}$

      The character ``\texttt{.}'' is a regular expression that matches character that is different
      from a Unicode line break.  The following unicode characters count as line breaks:
      gewertet:
      \\[0.2cm]
      \hspace*{1.3cm}
       ``\texttt{\symbol{92}n}'', ``\texttt{\symbol{92}r}'',
       ``\texttt{\symbol{92}u2028}'',
       ``\texttt{\symbol{92}u2029}'',
       ``\texttt{\symbol{92}u000B}'',
       ``\texttt{\symbol{92}u000C}'' und
       ``\texttt{\symbol{92}u0085}''.
\item $\texttt{\symbol{92}}x \in \textsl{Regexp}$ \quad provided $x \in \{ \texttt{a}, \texttt{b}, \texttt{f}, \texttt{n}, \texttt{r}, \texttt{t},
      \texttt{v}, \texttt{R} \}$. 

      Preceding certain characters with a backslash character ``\texttt{\symbol{92}}'' enables us to
      specify control characters.  We have:
      \begin{enumerate}
      \item \texttt{\symbol{92}a} matches the control character \texttt{Ctrl-G} (\emph{alert}).
      \item \texttt{\symbol{92}b} matches the control character \texttt{Ctrl-H} (\emph{backspace}).
      \item \texttt{\symbol{92}f} matches the control character \texttt{Ctrl-L} (\emph{form feed}).
      \item \texttt{\symbol{92}n} matches the control character \texttt{Ctrl-J} (\emph{newline}).
      \item \texttt{\symbol{92}r} matches the control character \texttt{Ctrl-M} (\emph{carriage return}).
      \item \texttt{\symbol{92}t} matches the control character \texttt{Ctrl-I} (\emph{tabulator}).
      \item \texttt{\symbol{92}v} matches the control character \texttt{Ctrl-K} (\emph{vertical tabulator}).
      \item \texttt{\symbol{92}R} matches any unicode line break.
      \end{enumerate}
\item $\texttt{\symbol{92}}abc \in \textsl{Regexp}$ \quad provided $a,b,c \in \{ \texttt{0}, \cdots \texttt{7} \}$ 

      If we use the syntax $\texttt{\symbol{92}}abc$, then $a$, $b$ and $c$ are octal digits and,
      furthermore, $abc$ has to be less than 128 when interpreted as octal number.
      In this case, the regular expression  $\texttt{\symbol{92}}abc$ matches the character that has
      the \textsc{Ascii} code  $abc$.  For example, since the \textsc{Ascii} code of the blank is 32
      in base 10, which is $40_8$ in the octal system, the regular expression
      ``\texttt{\symbol{92}040}'' matches the blank character \mbox{``\texttt{ }''}.

      The biggest number that can be interpreted as an \textsc{Ascii} code is the number 127.
      In octal, this number is written as $177_{8}$.
\item $\texttt{\symbol{92}x}ab \in \textsl{Regexp}$ \quad provided $a,b \in \{ \texttt{0}, \cdots, \texttt{9}, \mathtt{a},\cdots, \mathtt{f}, \mathtt{A},\cdots, \mathtt{F} \}$ 

      If we use the syntax $\texttt{\symbol{92}x}ab$, then $a$ and $b$ have to be hexadecimal
      digits.  Then $\texttt{\symbol{92}x}ab$ matches the character that has the number $ab$ where
      this number is interpreted in the hexadecimal system. 
      For example, the expression ``\texttt{\symbol{92}x5A}'' specifies the character  ``\texttt{Z}''
      because the character ``\texttt{Z}'' has the decimal \textsl{Ascii} code of $90$ and in the
      hexadecimal system this number is written as $\texttt{0x5A}$ since we have $90 = 5 \cdot 16 + 10$.
\item $\texttt{\symbol{92}u}abcd \in \textsl{Regexp}$ \quad provided $a,b,c,d \in \{ \texttt{0}, \cdots, \texttt{9}, \mathtt{a},\cdots, \mathtt{f}, \mathtt{A},\cdots, \mathtt{F} \}$ 

      If we use the syntax $\texttt{\symbol{92}u}abcd$, then $a$, $b$, $c$ and $d$ have to be
      hexadecimal digits.  The regular expression  $\texttt{\symbol{92}u}abcd$ matches the unicode
      character whose position is given by the formula
      \\[0.2cm]
      \hspace*{1.3cm}
      $a \cdot 16^3 + b \cdot 16^2 + c \cdot 16 + d$.
      \\[0.2cm]
      For example, the regular expression \texttt{\symbol{92}u2200} specifies the unicode character ``$\forall$''.
\item $\texttt{\symbol{92}U}abcdef \in \textsl{Regexp}$ \quad provided $a,b,c,d,e,f \in \{ \texttt{0}, \cdots, \texttt{9}, \mathtt{a},\cdots, \mathtt{f}, \mathtt{A},\cdots, \mathtt{F} \}$ 

      In the regular expression $\texttt{\symbol{92}U}abcdef$ the variables  $a$, $b$, $c$, $d$,
      $e$, and $f$ are interpreted as hexadecimal digits.  The expression
      $\texttt{\symbol{92}U}abcdef$ matches the unicode character whose position is given by the
      expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $a \cdot 16^5 + b \cdot 16^4 + c \cdot 16^3 + d \cdot 16^2 + e \cdot 16 + f$.
\item $\texttt{\symbol{92}}o \in \textsl{Regexp}$ \quad provided $o \in \textsl{OpSyms}$ 
      
      in order to match an operator symbol literally, we just have to precede it with a backslash.
      For example, the regular expression ``\texttt{\symbol{92}*}'' matches the string ``\texttt{*}''.
\item $r_1r_2 \in \textsl{Regexp}$ \quad provided $r_1,r_2 \in \textsl{Regexp}$

      The concatenation of two regular expressions is written without the  infix operator
      ``$\cdot$'' in the syntax of \textsl{JFlex}.  Hence, the regular expression $r_1r_2$ matches
      any string $s$ that can be written in the form  $s = uv$ where the prefix $u$ is matched by
      $r_1$, while the suffix $v$ is matched by $r_2$.
\item $r_1\texttt{|}r_2 \in \textsl{Regexp}$ \quad provided $r_1,r_2 \in \textsl{Regexp}$

      The operator ``\texttt{|}'' is the choice operator.  The regular expression $r_1\texttt{|}r_2$
      matches all strings that are matched by $r_1$ as well as all strings matched by  $r_2$.
      In the previous chapter, we had used the  operator ``\texttt{+}'' to achieve the same effect.
      However, the operator ``\texttt{+}'' is interpreted differently in \textsl{JFlex}.
\item $r\texttt{*} \in \textsl{Regexp}$ \quad provided $r \in \textsl{Regexp}$

      The postfix operator ``\texttt{*}'' denotes the Kleene closure.  Hence, the regular expression
      $r\texttt{*}$ matches any string $s$ that can split up into $n$ substrings $t_1$, $\cdots$,
      $t_n$, i.e.~we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $s = t_1\cdots t_n$
      \\[0.2cm]
      provided $r$ matches every substring $t_i$ for $i=1, \cdots, n$.  Furthermore, $r\texttt{*}$
      matches the empty string.
\item $r\texttt{+} \in \textsl{Regexp}$ \quad provided $r \in \textsl{Regexp}$

      The expression ``$r\texttt{+}$'' is a variant of the Kleene closure.  The only difference
      between  ``$r\texttt{+}$'' and  ``$r\texttt{*}$'' is that  ``$r\texttt{+}$'' does not match
      the empty string.  Algebraically, we have the following relation between these two regular expressions:
      \\[0.2cm]
      \hspace*{1.3cm}
      $r\texttt{+} \doteq rr\mathtt{*}$.
\item $r\texttt{?} \in \textsl{Regexp}$ \quad provided $r \in \textsl{Regexp}$

      The regular expression  ``$r\texttt{?}$'' specifies the same strings specified by $r$, but
      additionally matches the empty string.  Algebraically, we have the following equivalence:
      \\[0.2cm]
      \hspace*{1.3cm}
      $r\texttt{?} \doteq r|\varepsilon$.
      \\[0.2cm]
      Note, however, that \textsl{JFlex} does not support the use of the expression  ``$\varepsilon$'' 
      to denote the empty string.
\item $r\texttt{\{}n\texttt{\}} \in \textsl{Regexp}$ \quad provided $n \in \mathbb{N}$ and $r \in \textsl{Regexp}$

      The regular expression  ``$r\texttt{\{}n\texttt{\}}$'' specifies that $r$ has to occur exactly
      $n$ times.  For example, the regular expression ``\texttt{a\{4\}}'' matches the string
      ``\texttt{aaaa}''. 
\item $r\texttt{\{}m,n \texttt{\}} \in \textsl{Regexp}$ \quad provided $m,n \in \mathbb{N}$ and $m \leq n$ and $r \in \textsl{Regexp}$

      The regular expression  ``$r\texttt{\{}m,n\texttt{\}}$'' specifies that  $r$ has to occur at
      least $m$ times and most occur at most  $n$ times.
      Therefore, the regular expression  ``\texttt{a\{3,5\}}'' matches all of the following strings:
      \\[0.2cm]
      \hspace*{1.3cm}
      ``\texttt{aaa}'', ``\texttt{aaaa}'' and ``\texttt{aaaaa}''.
\item $\texttt{\symbol{94}}r$ \quad provided $r \in \textsl{Regexp}$

      The regular expression  $\texttt{\symbol{94}}r$ specifies that the substring matched by the
      regular expression  $r$ has to occur at the beginning of a line.

      The operator ``\texttt{\symbol{94}}'' must only be used as the outermost operator inside a regular
      expression.  For example
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{\symbol{94}}r_1|r_2$
      \\[0.2cm]
      is not a regular expression, because here ``\texttt{|}'' is the outermost operator that is used.
\item $r\texttt{\symbol{36}}$ \quad provided $r \in \textsl{Regexp}$

      The regular expression $r\texttt{\symbol{36}}$ specifies that the regular expression $r$ has
      to occur at the end of a line.

      The usage of the operator  ``\texttt{\symbol{36}}'' suffers a similar restriction as the usage
      of the operator ``\texttt{\symbol{94}}'':  The operator ``\texttt{\symbol{36}}'' has to be the
      outermost operator of the regular expression.  Hence,
      \\[0.2cm]
      \hspace*{1.3cm}
      $r_1|r_2\texttt{\symbol{36}}$
      \\[0.2cm]
      is not a regular expression because here the operator ``\texttt{|}'' would be the outermost
      operator.
\item $r_1\texttt{/}r_2$ \quad provided $r_1, r_2 \in \textsl{Regexp}$
  
      The regular expression $r_1\texttt{/}r_2$ specifies that the text matched by the regular
      expression  $r_1$ has to be followed by text that matches the regular expression $r_2$.
      However, in contrast to the concatenation $r_1r_2$ the regular expression $r_1/r_2$ matches
      only the string matched by $r_1$.
      Hence, the  operator ``\texttt{/}'' can be seen as posing an additional constraint to the
      regular expression $r_1$.

      The method ``\texttt{yytext()}'', which returns the substring that has been matched, only
      returns the string that has been matched by $r_1$, while the string matched by  $r_2$ remains
      unprocessed. The string matched by $r_2$ is known as \emph{trailing context}.

      The operator ``\texttt{/}'' must always be the outermost operator of the regular expression in
      which it occurs.  This is the same restriction that we have for the operators
      ``\texttt{\symbol{36}}'' and ``\texttt{\symbol{94}}''.
\item $(r) \in \textsl{Regexp}$ \quad provided $r \in \textsl{Regexp}$

      We can use parentheses in regular expressions to group the operators.
      The precedences of the various operators are specified as follows:
      The  postfix operators ``\texttt{*}'', ``\texttt{?}'', ``\texttt{+}'',
      ``\texttt{\{}$n$\texttt{\}}'' and ``\texttt{\{}$m$,$n$\texttt{\}}'' have the highest
      precedence, while the operator ``\texttt{|}'' has the lowest precedence.
\end{enumerate}
All of the operators discussed so far can also be used with the tool  \textsl{Flex} that is used to
build \texttt{C} parsers. In addition, \textsl{JFlex} supports the negation operator ``\texttt{!}''
and the  \textsl{upto} operator ``\texttt{\symbol{126}}''.  We will discuss these operators later.

The specification of regular expressions is not complete, because we haven't  discussed the notion of a 
\emph{character class} so far.  A character class specifies a set of characters in a compact way.
This is done using the square brackets ``\texttt{[}'' and ``\texttt{]}''.
For example, the vowels can be specified using the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[aeiou]}.
\\[0.2cm]
This regular expression serves as an abbreviation of the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{a|e|i|o|u}.
\\[0.2cm]
In order to specify the set of all lower case Latin characters we can use the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[a-z]}
\\[0.2cm]
since we have the following equivalence:
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{[a-z]} \doteq \texttt{a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z}$.
\\[0.2cm]
The set containing  all Latin characters and the underscore is specified vie the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[a-zA-Z\_]}.
\\[0.2cm]
With \textsl{JFlex} it is possible to build the complement of a character class.  In order to do
this, we have to use the operator ``\texttt{\symbol{94}}'' immediately after the opening square
bracket.  For example, the regular expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{[\symbol{94}0-9]}
\\[0.2cm]
specifies all characters that are not decimal digits..  


\examplesEng
In order to aid the understanding of the previous material we provide some examples next.
\begin{enumerate}
\item \texttt{[a-zA-Z][a-zA-Z0-9\_]*}

      This regular expression specifies all those strings that solely consist of Latin characters,
      decimal digits and the underscore and that, furthermore, start with a character.

\item \texttt{\symbol{92}/\symbol{92}/.*}

      This regular expression specifies a one line comment in the programming language \texttt{C}.
      The regular expression matches any string that starts with two slashes and extends to the
      first line break.
\item \texttt{0|[1-9][0-9]*}

      This regular expression matches natural numbers that are coded in the decimal system and that
      do not have leading zeros.  The important thing here is to make sure that a string beginning
      with the character ``\texttt{0}'' must not contain any further digits if the string is
      supposed to represent a natural number.
\end{enumerate}


Our previous discussion of regular expressions is incomplete.  Below are some features that are
unique to the regular expressions supported by \textsl{JFlex}.
\begin{enumerate}
\item Regular expressions can be formatted using white space characters.
      However, white space is not allowed inside character classes.
      Hence, In order to match a space character we can use the regular expression
      ``\texttt{[ ]}'', while the horizontal tab character can be matched using the regular
      expression ``\texttt{\symbol{92}t}''.
\item Inside double quotes with one exception all operator symbols use their status as operator
      symbols and just match themselves.  The exception is the backslash character
      ``\texttt{\symbol{92}}''.  For example, the regular expression 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}/*\symbol{34}}
      \\[0.2cm]
      matches the start of a multi line \texttt{C} comment.  Although both the characters
      ``\texttt{/}'' and ``\texttt{*}'' are operator symbols, they match themselves because they are
      used inside double quotes in the regular expression given above.
\item \textsl{JFlex} supports the negation operator ``\texttt{!}''.  This operator is used as a
      prefix operator.  If $r$ is a regular expression, then the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      $\texttt{!}r$      
      \\[0.2cm]
      matches all those strings that are not matched by $r$.

      The precedence of the negation operator ``\texttt{!}'' is lower than the precedence of the
      postfix operators ``\texttt{+}'', ``\texttt{*}'', ``\texttt{?}'', ``\texttt{\{$m$\}}'', and
      ``\texttt{\{$m$, $n$\}}'', but higher than the precedence of the concatenation.
      Therefore, the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{!a+b} \quad is equivalent to \quad
      \texttt{(!(a+))b}.
      \\[0.2cm]
      The negation operator is very useful.  For example, in order to recognize multi line comments
      in the programming language \texttt{C}, we can use the following regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}/*\symbol{34} !([\symbol{94}]* \symbol{34}*/\symbol{34} [\symbol{94}]*) 
              \symbol{34}*/\symbol{34}}
      \\[0.2cm]
      Let us discuss this regular expression in detail:
      \begin{enumerate}
      \item First, we have to match the substring  ``\texttt{/*}''.  This is done by the regular expression
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{34}/*\symbol{34}}
            \\[0.2cm]
            We have enclosed the substring \texttt{/*} in double quotes to prevent these characters
            from acting as operators.
      \item The inner part of a multi line comment must not contain the substring ``\texttt{*/}''.
            The regular expression ``\texttt{[\symbol{94}]}'' specifies the complement of the empty
            character class.  Hence, it specifies an arbitrary character. 
            Therefore the regular expression
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{[\symbol{94}]* \symbol{34}*/\symbol{34} [\symbol{94}]*}
            \\[0.2cm]
            matches any string that  contains the string ``\texttt{*/}''.  This string may be
            preceded and succeeded by arbitrary characters.    
            wobei vorher und nachher beliebige Zeichen stehen können.  Therefore, the negation of
            this regular expression specifies exactly those strings that can appear inside a multi
            line comment: The only requirement in a multi line comment is that the string between
            the opening  ``\texttt{/*}'' and the closing ``\texttt{*/}'' must not contain the
            substring ``\texttt{*/}''.
      \item The multi line comment ends with the substring ``\texttt{*/}'' which is matched by the
        corresponding regular expression.
      \end{enumerate}
      The  negation operator can be used to specify the intersection of two regular expressions
      $r_1$ and $r_2$:  Using  De Morgan's laws from propositional logic we have that
      \\[0.2cm]
      \hspace*{1.3cm}
      $f_1 \wedge f_2 \leftrightarrow \neg(\neg f_1 \vee \neg f_2)$
      \\[0.2cm]
      holds for any propositional formul\ae\  $f_1$ und $f_2$.  Hence, the intersection of two regular
      expressions $r_1$ and $r_2$ can be defined as
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{!(!$r_1$|!$r_2$)}.
      \\[0.2cm]
      This regular expression matches all those strings that are matched by both
      $r_1$ and $r_2$.

      Experience shows that the regular expressions that contains nested applications of the
      negation operator lead to finite state machines that may have huge numbers of states.
      Hence this feature should be used with caution.
\item As a further convenience,  \textsl{JFlex} provides the \emph{upto} operator ``\texttt{\symbol{126}}''.
      If $r$ is a regular expression, the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{126}}$r$
      \\[0.2cm]
      specifies any string that ends in $r$ but does not contain $r$ excpet at the end.
      Using the upto operator, multi line comments of the programming language \texttt{C} can be
      specified using the following regular expression:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}/*\symbol{34} \symbol{126}\symbol{34}*/\symbol{34}}
      \\[0.2cm]
      This regular expression works as follows:  A multi line comment starts with the string
      ``\texttt{/*}'' and ends with the first occurrence of the string ``\texttt{*/}''.

      Internally, the upto operator is implemented using the negation operator.  The regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{126}}$r$ \qquad is translated into the regular expression \qquad
      \texttt{!([\symbol{94}]* $r$ [\symbol{94}]*) $r$}.
      \\[0.2cm]
      Here, ``\texttt{!([\symbol{94}]* $r$ [\symbol{94}]*)}'' specifies any string that does not
      contain $r$.  This string then has to be followed by $r$.
\item \textsl{JFlex} supports certain character classes that are predefined in \textsl{Java}.
      For example, the regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[:digit:]}
      \\[0.2cm]
      specifies a digit.  The following character classes are provided in \textsl{JFlex}.  Each
      of these character classes is corresponds to a method in the class \texttt{java.lang.Character}:
      \begin{enumerate}
      \item \texttt{[:jletter:]} is implemented via the method
            $\texttt{isJavaIdentifierStart}()$.
            
            Hence, the regular expression \texttt{[:jletter:]} specifies those characters that cause
            the method 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\mathtt{Character}.\texttt{isJavaIdentifierStart}(c)$
            \\[0.2cm]
            to return the result \texttt{true}.
      \item \texttt{[:jletterdigit:]} is reduced to the method
            $\texttt{isJavaIdentifierPart}()$.
      \item \texttt{[:letter:]} is reduced to the method
            $\texttt{isLetter}()$.
      \item \texttt{[:digit:]} is reduced to the method
            $\texttt{isDigit}()$.
      \item \texttt{[:uppercase:]} is reduced to the method
            $\texttt{isUppercase}()$.
      \item \texttt{[:lowercase:]} is reduced to the method
            $\texttt{isLowercase}()$.
      \end{enumerate}
\item Furthermore,  \textsl{JFlex} supports  unicode character classes using the syntax 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}p\{\textsl{className}\}}.
      \\[0.2cm]
      Here, \textsl{className} can be any unicode character class.  For example, 
      the unicode character class \texttt{greek} is the set of all Greek letters.  Hence, the
      regular expression
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}p\{greek\}}
      \\[0.2cm]
      can be used to search for Greek letters.  In order to negate a  unicode character class we can
      use the syntax
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{92}P\{\textsl{className}\}}.
      \\[0.2cm]
      For example, the regular expression
      \texttt{\symbol{92}P\{greek\}}
      \\[0.2cm]
      matches all characters that are not Greek letters.
      
      If you are interested in knowing which unicode character classes exist, you can call 
      \texttt{jflex} using the following command:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{jflex -uniprops 7.0}
      \\[0.2cm]
      Here, the ``\texttt{7.0}'' specifies the version of  unicode that is supported.
 \end{enumerate}

\section{Further \textsl{JFlex} Options}
This section discusses the most important options that can be used in the options part of a 
\textsl{JFlex} specification.  All options start with the character ``\texttt{\%}''.
This character has to be the first character in the line.  Hence, options must not be indented.
\begin{enumerate}
\item \texttt{\%char}

      This options causes the characters to be counted.  If this option is used, the actions can use
      the variable \texttt{yychar}.  This  variable is of type \texttt{int} and it contains the
      number of characters that have been processed by the scanner so far.
\item \texttt{\%line}

      This option causes lines to be counted.  If this option is specified, the
      variable \texttt{yyline} contains the number of lines that have been read.
\item \texttt{\%column}

      This option counts how many characters have been read since the last line break.
      Ths number is stored in the variable \texttt{yycolumn}.  Hence,  \texttt{yycolumn} contains
      the column of the last character that has been read.
\item \texttt{\%cup}

      This option specifies that \textsl{JFlex} is used to generate a scanner that is to be used by
      a parser generated form the  parser generator \textsc{Cup}.  We will explain and use this
      option later once we start to discuss \textsc{Cup}.
\item \texttt{\%ignorecase}

      If this option is used, then the case of the characters is ignored.  For example, with this
      option the regular expression
      ``\texttt{[a-z]+}'' will also match the string ``\texttt{ABC}''.
\end{enumerate}

\section{A Complex Example: Computing Marks for an Exam}
In diesem Abschnitt diskutieren wir eine Anwendung von \textsl{JFlex}.  Es geht dabei um die
Auswertung von Klausuren.   Bei der Korrektur einer Klausur lege ich eine Datei an, die das 
in Abbildung \ref{fig:ergebnis} beispielhaft gezeigte Format besitzt.

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    Klausur: Algorithmen und Datenstrukturen
    Kurs:    TIT09AID
    
    Aufgaben:            1. 2. 3. 4. 5. 6.
    Max Müller:          9 12 10  6  6  0
    Dietmar Dumpfbacke:  4  4  2  0  -  -
    Susi Sorglos:        9 12 12  9  9  6
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Klausurergebnisse}
\label{fig:ergebnis}
\end{figure}

\begin{enumerate}
\item Die erste Zeile enthält nach dem Schlüsselwort \texttt{Klausur} den Titel der Klausur.
\item Die zweite Zeile gibt den Kurs an.
\item Die dritte Zeile ist leer.
\item Die vierte Zeile gibt die Nummern der einzelnen Aufgaben an.
\item Danach folgt eine Tabelle.  Jede Zeile dieser Tabelle listet die Punkte auf,
      die ein Student erzielt hat.  Der Name des Studenten wird dabei am Zeilenanfang angegeben.
      Auf den Namen folgt ein Doppelpunkt und daran schließen sich dann Zahlen an, die angeben,
      wieviele Punkte bei den einzelnen Aufgaben erzielt wurden.  Wurde eine Aufgabe nicht
      bearbeitet, so steht in der entsprechenden Spalte ein Bindestrich ``\texttt{-}''.
\end{enumerate}
Das \textsl{JFlex}-Programm, das wir entwickeln werden, berechnet zunächst die Summe
\texttt{sumPoints} aller Punkte, die ein Student erzielt hat.  Aus dieser Summe wird dann nach der
Formel 
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{note} = 7 - 6 \cdot \bruch{\;\texttt{sumPoints}\;}{\texttt{maxPoints}}$
\\[0.2cm]
die Note errechnet, wobei die Variable \texttt{maxPoints} die  Punktzahl
angibt, die für die Note 1,0 benötigt wird.  Diese Zahl ist ein Argument, das dem Programm
beim Start übergeben wird. 


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    %%
    %class Exam
    %int        // declare return type of yylex
    %line
    %column
    %unicode
    %{
        public int mMaxPoints = 0;
        public int mSumPoints = 0;
        public double mark() {
            return 7.0 - 6.0 * mSumPoints / mMaxPoints;
        } 
        public void errorMsg() {
            System.out.printf("invalid character '%s' at line %d, column %d\n", 
                              yytext(), yyline + 1, yycolumn + 1); 
        }    
        public static void main(String argv[]) {
            if (argv.length != 2) {
                System.out.println("Usage : java Exam <inputfile> <maxPoints>");
            } else {
                Exam scanner = null;
                try {
                    scanner            = new Exam(new java.io.FileReader(argv[0]));
                    scanner.mMaxPoints = new Integer(argv[1]);
                    scanner.yylex();
                } catch (java.io.FileNotFoundException e) {
                    System.out.println("File not found : \"" + argv[0] + "\"");
                } catch (java.io.IOException e) {
                    System.out.println("IO error scanning \"" + argv[0] + "\"");
                    System.out.println(e);
                } 
            }
        } 
    %}
    ZAHL = 0|[1-9][0-9]*
    NAME = [A-Za-zäöüÄÖÜß]+[ ][A-Za-zäöüÄÖÜß\-]+
    %% 
    
    [A-Za-z]+:.*\R { /* skip header                         */ }
    {NAME}/:       { System.out.print(yytext()); 
                     mSumPoints = 0;                           }
    :[ \t]+        { System.out.print(yytext());               }
    {ZAHL}         { mSumPoints += new Integer(yytext());      }
    -              { /* skip hyphens                        */ }
    [ \t]          { /* skip white space                    */ }
    ^[ \t]*\R      { /* skip empty line                     */ }
    \R             { System.out.printf(" %3.1f\n", mark());    }
    .              { errorMsg();                               }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Berechnung von Noten mit Hilfe von \textsl{JFlex}.}
\label{fig:note.jflex}
\end{figure}

Abbildung \ref{fig:note.jflex} zeigt die \textsl{JFlex}-Spezifikation, aus der sich
automatisch ein \textsl{Java}-Programm zur Noten-Berechnung erstellen lässt.
\begin{enumerate}
\item Zeile 2 legt den Namen der Klasse fest.
\item In Zeile 3 spezifizieren wir durch die Option ``\texttt{int}'', dass die
      Scanner-Methode \textsl{yylex()} den Rückgabe-Wert \texttt{int} hat.
      
      Dies ist deswegen erforderlich, weil in einem Scanner, der nicht als
      \texttt{standalone} deklariert ist, dieser Rückgabe-Wert den Typ \texttt{Yytoken} hat.
      Die Klasse \texttt{Yytoken} wird allerdings von \textsl{JFlex} selber gar nicht definiert, denn
      \textsl{JFlex} erwartet, dass diese Klasse von dem Parser, an dem der Scanner
      angeschlossen wird, definiert wird.  Da wir gar keinen Parser anschließen wollen,
      wäre der Typ \texttt{Yytoken} dann undefiniert.  Um zu vermeiden, dass der
      Rückgabe-Wert der Methode \texttt{yylex()} den Typ \texttt{Yytoken} bekommt,
      könnten wir den Scanner auch als \texttt{standalone} deklarieren, aber dann
      hätten wir keine Möglichkeit mehr,
      die Methode \texttt{main()} anzugeben.  Diese Methode benötigen wir, um die dem
      Programm als Argument übergebene Punktzahl einlesen zu können.
\item In den Zeilen 8 und 9 deklarieren wir die Variablen \texttt{mMaxPoints} und
      \texttt{mSumPoints} als Member-Variablen der erzeugten Klasse.
\item In der Methode \texttt{main()} erzeugen wir zunächst in Zeile 23 den Scanner und
      setzen dann in Zeile 24 die Variable \texttt{mMaxPoints} auf den beim Aufruf
      übergebenen Wert.  Der Scanner wird durch den Aufruf in Zeile 25 gestartet.

\item In dem Definitions-Abschnitt werden zwei \emph{Abkürzungen} definiert:
      \begin{enumerate}
      \item Zeile 35 enthält die Definition von \texttt{ZAHL}.  Mit dieser Definition können
            wir später anstelle des regulären Ausdrucks
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{0|[1-9][0-9]*}
            \\[0.2cm]
            kürzer ``\texttt{\{ZAHL\}}'' schreiben.  Beachten Sie, dass der Name einer Abkürzung
            bei der Verwendung der Abkürzung in geschweiften Klammern eingefasst werden muss.
      \item Zeile 36 enthält die Definition von \texttt{NAME}.  In dem regulären Ausdruck
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{[A-Za-zöäüÖÄÜß]+[ ][A-Za-zöäüÖÄÜß]+}
            \\[0.2cm]
            wird festgelegt, dass ein Name aus großen und kleinen lateinischen
            Buchstaben sowie Umlauten besteht und dass Vor- und Nachname durch ein
            Leerzeichen getrennt werden.
      \end{enumerate}
\item Der Regel-Abschnitt erstreckt sich von Zeile 39 -- 48.
      \begin{enumerate}
      \item Die Regel in Zeile 39 dient dazu, die beiden Kopfzeilen
            der zu verarbeitenden Datei zu lesen.  Diese Zeilen bestehen jeweils aus einem Wort,
            auf das ein Dopplepunkt folgt.  Dahinter steht beliebiger Text, der mit einem
            Zeilenumbruch endet.  
      \item Die Regel in Zeile 40 liest den Namen eines Studenten, dem ein Doppelpunkt
            folgen muss.  Da wir den Doppelpunkt mit dem Operator ``\texttt{/}''von dem Namen
            abtrennen, ist der Doppelpunkt nicht Bestandteil des von dieser Regel gelesenen Textes.
            Dadurch können wir den Doppelpunkt in der nächsten Regel noch benutzen.

            Wenn wir einen Namen gelesen haben, geben wir diesen mit Hilfe eines
            \texttt{print}-Befehls aus.  Sie sehen hier, dass wir mit Hilfe der Methode
            $\texttt{yytext()}$ auf den durch den regulären Ausdruck erkannten Text
            zugreifen können.

            Anschließend setzen wir die Variable \texttt{mSumPoints}
            auf 0.  Dies ist erforderlich, weil diese Variable ja noch die Punkte eines
            anderen Studenten enthalten könnte.
      \item Die nächste Regel in Zeile 42 liest die Leerzeichen und Tabulatoren ein, die auf 
            den Doppelpunkt folgen und gibt diese aus.  Dadurch erreichen wir, dass die Ausgabe
            der Noten genauso formatiert wird wie die Eingabe-Datei.
      \item Die Regel in Zeile 43 dient dazu, die Punkte, die der Student bei einer Aufgabe 
            erreicht hat, einzulesen.  Da die Zahl zunächst nur als String zur Verfügung steht,
            müssen wir diesen String in eine Zahl
            umwandeln.  Dazu benutzen wir den Konstruktor der Klasse \texttt{Integer}.
            Anschließend wird diese Zahl dann zu der Summe der Punkte hinzuaddiert.
      \item Für nicht bearbeitete Aufgaben enthält die Eingabe-Datei einen Bindestrich
            ``\texttt{-}''.  Diese Bindestriche werden durch die Regel in Zeile 44
            eingelesen und ignoriert.  Daher ist das Kommando dieser Regel (bis auf den Kommentar)
            leer.
      \item In der gleichen Weise überlesen wir mit der Regel in Zeile 45
            Leerzeichen und Tabulatoren, die nicht auf einen Doppelpunkt folgen.
      \item Die Regel in Zeile 46 dient dazu Zeilen einzulesen, die nur aus Leerzeichen
            und Tabulatoren bestehen.  
      \item Wenn wir nun einen einzelnen Zeilenumbruch lesen, dann muss dieser von einer Zeile
            stammen, die die Punkte eines Studenten auflistet.  In diesem Fall berechnen wir mit
            der Regel in Zeile 47 die erzielte Note und geben diese mit einer Stelle hinter
            dem Komma aus.  
      \item Die bis hierhin vorgestellten Regeln ermöglichen es, eine syntaktisch korrekte 
            Eingabe-Datei zu verarbeiten.  Für den Fall, dass die Eingabe-Datei Syntaxfehler
            enthält, ist es sinnvoll, eine Fehlermeldung auszugeben, denn sonst könnte es passieren,
            dass auf Grund eines einfachen Tippfehlers eine falsche Note berechnet wird.
            Daher enthält Zeile 48 eine Default-Regel, die immer dann greift, wenn keine der
            anderen Regeln zum Zuge gekommen ist.  Diese Regel liest ein einzelnes Zeichen und
            gibt eine Fehlermeldung aus.  Diese Fehlermeldung enthält das gelesene Zeichen. 
            Außerdem werden die Variablen \texttt{yyline} und \texttt{yycolumn} benutzt um die
            Position des fehlerhaften Zeichens anzugeben.
            Wir benutzen hier die weiter oben definierte Methode \texttt{errorMsg}.
            Da diese Funktion eine Member-Funktion der erzeugten Scanner-Klasse ist,
            können wir innerhalb dieser Methode auf die beiden Variablen \texttt{yyline} und
            \texttt{yycolumn} zurückgreifen, denn diese Variablen sind Member-Variablen 
            der erzeugten Scanner-Klasse.

            Beachten Sie, dass \textsl{JFlex} beim Zählen von Zeilen und Spalten mit $0$ beginnt.
            Daher addieren wir jeweils noch $1$ zu den Werten von \texttt{yycolumn} und
            \texttt{yyline}. 
      \end{enumerate}
\end{enumerate}

\section{Zustände}
Viele syntaktische Konstrukte lassen sich zwar im Prinzip mit regulären Ausdrücken beschreiben,
aber die Ausdrücke, die benötigt werden, sind sehr unübersichtlich.  Ein gutes Beispiel
hierfür ist der reguläre Ausdruck zur Spezifikation von mehrzeilige
\texttt{C}-Kommentaren, also Kommentaren der Form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{/*} $\cdots$ \texttt{*/}
\\[0.2cm]
Wenn wir hier einen regulären Ausdruck angeben möchten, der weder den Upto-Operator noch
den Negations-Operator verwendet\footnote{
  Die meisten anderen Werkzeuge, die mit regulären
  Ausdrücken arbeiten, unterstützen weder den Negations-Operator noch den Upto-Operator.},
so müssten wir den folgenden regulären Ausdruck verwenden:
%\/\*([^*]|(\*+[^*/]))*\*+\/ 
\begin{equation}
  \label{eq:multiline-comment}
\texttt{\symbol{92}/\symbol{92}*([\symbol{94}*]|\symbol{92}*+[\symbol{94}*/])*\symbol{92}*+\symbol{92}/}  
\end{equation}
Zunächst ist dieser Ausdruck schwer zu lesen.  Das liegt vor allem daran,
dass die Operator-Symbole ``\texttt{/}'' und ``\texttt{*}'' durch einen Backslash
geschützt werden müssen.  Aber auch die Logik, die hinter diesem Ausdruck steht, ist nicht
ganz einfach.  Wir analysieren die einzelnen Komponenten dieses Ausdrucks:
\begin{enumerate}
\item \texttt{\symbol{92}/\symbol{92}*} 

      Hierdurch wird der String ``\texttt{/*}'', der den Kommentar einleitet,  spezifiziert.
\item \texttt{([\symbol{94}*]|\symbol{92}*+[\symbol{94}*/])*}
  
      Dieser Teil spezifiziert alle Zeichen, die zwischen dem öffnenden String ``\texttt{/*}''
      und einem schließenden String der Form ``\texttt{*/}'' liegen.  Wie müssen
      sicherstellen, dass dieser Teil die Zeichenreihe ``\texttt{*/}'' nicht enthält, denn
      sonst würden wir in einer Zeile der Form
      \\[0.2cm]
      \hspace*{1.3cm} \texttt{/* first */ ++n; /* second */}
      \\[0.2cm]
      den Befehl ``\texttt{++n;}'' für einen Teil des Kommentars halten.  Der erste Teil des
      obigen regulären Ausdrucks ``\texttt{[\symbol{94}*]}'' steht für ein beliebiges
      von ``\texttt{*}'' verschiedenes Zeichen.  Denn solange wir kein ``\texttt{*}'' lesen,
      kann der Text auch kein ``\texttt{*/}'' enthalten.  Das Problem ist, dass das Innere
      eines Kommentars aber durchaus das Zeichen ``\texttt{*}'' enthalten kann, es darf
      nur kein ``\texttt{/}'' folgen.  Daher spezifiziert die Alternative
      ``\texttt{\symbol{92}*+[\symbol{94}*/]}'' einen String, der aus beliebig vielen 
      ``\texttt{*}''-Zeichen besteht, auf die dann aber noch ein Zeichen folgen muss, dass
      sowohl von ``\texttt{/}'' als auch von ``\texttt{*}'' verschieden ist.
      
      Der Ausdruck ``\texttt{[\symbol{94}*]|\symbol{92}*+[\symbol{94}*/]}''
      spezifiziert jetzt also entweder ein Zeichen, das von ``\texttt{*}'' verschieden
      ist, oder aber eine Folge von ``\texttt{*}''-Zeichen, auf die dann noch ein von
      ``\texttt{/}'' verschiedenes Zeichen folgt.  Da solche Folgen beliebig oft vorkommen
      können, wird der ganze Ausdruck in Klammern eingefasst und mit dem Quantor
      ``\texttt{*}'' dekoriert.   
\item \texttt{\symbol{92}*+\symbol{92}/}

      Dieser reguläre Ausdruck spezifiziert das Ende des Kommentars.  Es kann aus einer 
      beliebigen positiven Anzahl von ``\texttt{*}''-Zeichen bestehen, auf die dann noch
      ein ``\texttt{/}'' folgt.  Wenn wir hier nur den Ausdruck
      ``\texttt{\symbol{92}*\symbol{92}/}'' verwenden würden, dann könnten wir Kommentare der
      Form 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{/*** blah ***/}
      \\[0.2cm]
      nicht mehr erkennen, denn der unter 2. diskutierte reguläre Ausdruck akzeptiert
      nur Folgen von ``\texttt{*}'', auf die kein ``\texttt{*}'' folgt.
\end{enumerate}

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    /**
      remove C comments from a file 
    */
    
    %%
    
    %class Decomment
    %standalone
    %unicode
    
    %%
    
    \/\*([^*]|\*+[^*/])*\*+\/ { /* skip multi  line comments */ }
    \/\/.*                    { /* skip single line comments */ }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Entfernung von Kommentaren aus einem C-Programm.}
\label{fig:decomment.jflex}
\end{figure}

\noindent
Abbildung \ref{fig:decomment.jflex} zeigt ein \textsl{JFlex}-Programm, das aus einem
\texttt{C}-Programm sowohl einzeilige Kommentare der Form ``\texttt{//} $\cdots$''
als auch mehrzeilige Kommentare der Form ``\texttt{/*} $\cdots$ \texttt{*/} entfernt.
Sie fragen sich an dieser Stelle vermutlich, was denn mit dem Teil des \texttt{C}-Programms
geschieht, der nicht Teil eines Kommentars ist.  Hier kommt die \emph{Default-Regel} von
\textsl{JFlex} zum tragen:  Jedes Zeichen,  das nicht durch eine der Regeln in dem
\textsl{JFlex}-Programm verarbeitet wird, wird unverändert auf der Standardausgabe ausgegeben.
Das hat zur Folge, dass das oben gezeigt \textsl{JFlex}-Programm genau die Kommentare aus einem
\texttt{C}-Programm löscht und den Rest des \texttt{C}-Programms unverändert ausgibt.

Das obige Programm zur Löschung von Kommentaren an sich ist zwar recht kurz, aber der reguläre Ausdruck zur Erkennung
mehrzeiliger Kommentare ist sehr kompliziert und damit nur schwer zu verstehen.
Es gibt zwei Möglichkeiten, um dieses Programm zu vereinfachen:
\begin{enumerate}
\item Wir könnten den oben bereits diskutierten Upto-Operator benutzen.
      Das ist sicher der einfachste Weg, wenn wir mit \textsl{JFlex} arbeiten.  Sollten wir
      allerdings mit einem Scanner-Generator wie \textsl{Flex} arbeiten, der diesen Operator nicht
      unterstützt, dann entfällt diese Möglichkeit.
\item Alternativ können wir auch mit sogenannten \emph{Start-Zuständen} arbeiten.
      Wir werden diese letzte Möglichkeit jetzt anhand eines weiteren Beispiels vorführen,
      das wir im folgenden Abschnitt diskutieren.
\end{enumerate}

\subsection{Entfernung von \textsc{Html}-Tags}
In diesem Abschnitt wollen wir ein Programm erstellen, das in der Lage ist, eine 
\textsc{Html}-Datei in eine reine Text-Datei konvertieren.  Ein solches Programm ist durchaus
nützlich: Vor einigen Jahren hatte ich einen blinden Studenten, der Webseiten nur über eine
Braille-Zeile lesen konnte.  Für ihn waren die Formatierungs-Tags, die in einer typischen
\textsc{Html}-Datei enthalten sind, nur störend.

Die \textsl{JFlex}-Spezifikation, die
in Abbildung \ref{fig:html2txt.jflex} gezeigt wird, führt die folgenden Aktionen durch:
\begin{enumerate}
\item Zunächst wird der Kopf der \textsc{Html}-Datei, der in den Tags ``\texttt{<head>}''
      und ``\texttt{</head>}'' eingeschlossen ist, entfernt.
\item Die Skripte, die in der \textsc{Html}-Datei enthalten sind, werden ebenfalls
      entfernt.
\item Außerdem werden die \textsc{Html}-Tags entfernt.
\end{enumerate}
Zur Deklaration der verschiedenen Zustände wird das Schlüsselwort
``\texttt{\symbol{37}xstate}'' verwendet. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    package Converter;
    
    %% 
    
    %class Html2Txt
    %standalone
    %line
    %unicode
    
    %xstate header script
    %%
    
    "<head>"            { yybegin(header);         }
    "<script"[^>]+">"   { yybegin(script);         }
    "<"[^>]+">"         { /* skip html tags */     }
    \R+                 { System.out.print("\n");  }
    &nbsp;              { System.out.print(" ");   }
    &auml;              { System.out.print("ä");   }
    &ouml;              { System.out.print("ö");   }
    &uuml;              { System.out.print("ü");   }
    &Auml;              { System.out.print("Ä");   }
    &Ouml;              { System.out.print("Ö");   }
    &Uuml;              { System.out.print("Ü");   }
    &szlig;             { System.out.print("ß");   }
    
    <header>"</head>"   { yybegin(YYINITIAL);      }
    <header>.|\R        { /* skip anything else */ }
    
    <script>"</script>" { yybegin(YYINITIAL);      }
    <script>.|\R        { /* skip anything else */ }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Transformation einer \textsc{Html}-Datei in eine reine Text-Datei}
\label{fig:html2txt.jflex}
\end{figure}

Wir diskutieren jetzt die in Abbildung \ref{fig:html2txt.jflex} gezeigte
\textsl{JFlex}-Datei im Detail.
\begin{enumerate}
\item In Zeile 10 deklarieren wir die beiden \textsl{Zustände}\/
      \texttt{header} und \texttt{script} über das Schlüsselwort ``\texttt{\%xstate}''
      als \emph{exklusive} Start-Zustände.
      Die allgemeine Syntax einer solchen Deklaration ist wie folgt:
      \begin{enumerate}
      \item Am Zeilen-Anfang einer Zustands-Deklaration steht der String ``\texttt{\symbol{37}xstate}''
            oder ``\texttt{\symbol{37}state}''.  
            Der String ``\texttt{\symbol{37}xstate}'' spezifiziert \emph{exklusive} Zustände,
            der String ``\texttt{\symbol{37}state}'' spezifiziert \emph{inklusive} Zustände.
            Den Unterschied zwischen diesen beiden Zustandsarten erklären wir später.
      \item Darauf folgt eine Liste der Namen der deklarierten Zustände.  Die Namen werden
            durch Leerzeichen getrennt.
      \end{enumerate}
\item In Zeile 13 haben wir den String ``\texttt{<head>}'' in doppelte Hochkommata
      eingeschlossen.  Dadurch verlieren die Operator-Symbole ``\texttt{<}'' ihre
      Bedeutung.  Dies ist eine allgemeine Möglichkeit, um Operator-Symbole in
      \textsl{JFlex}\/ spezifizieren zu können.  Wollen wir beispielsweise den String
      ``\texttt{a*}''  wörtlich erkennen, so können wir an Stelle von ``\texttt{a\symbol{92}*}''
      auch klarer
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}a*\symbol{34}}
      \\[0.2cm]
      schreiben.
      
      Wird der String ``\texttt{<head>}'' erkannt, so wird in Zeile 13 die Aktion 
      ``\texttt{yybegin(header)}'' ausgeführt.  Damit wechselt der Scanner aus dem
      Default-Zustand ``\texttt{YYINITIAL}'', in dem der Scanner startet,
      in den oben deklarierten Zustand \texttt{header}.
      Da dieser Zustand als \emph{exklusiver} Zustand deklariert worden ist, können jetzt
      nur noch solche Regeln angewendet werden, die mit dem Prefix ``\texttt{<header>}''
      beginnen.  Wäre der Zustand als \emph{inklusiver} Zustand deklariert worden, so könnten auch solche 
      Regeln verwendet werden, die nicht mit einem Zustand markiert sind.  Solche Regeln
      sind implizit mit dem Zustand ``\texttt{<YYINITIAL>}'' markiert.
      
      Die Regeln, die mit dem Zustand ``\texttt{header}'' markiert sind, finden wir weiter
      unten in den Zeilen 26 und 27.
\item In Zeile 14 wechseln wir entsprechend in den Zustand ``\texttt{script}'' wenn
      wir ein öffnendes \texttt{Script}-Tag sehen.
\item In Zeile 15 werden alle restlichen Tags gelesen.  Da die Aktion hier leer ist,
      werden diese Tags einfach entfernt.
\item In Zeile 16 ersetzen wir die Zeichenreihe ``\texttt{\&nbsp;}'' durch ein Blank.
\item  In den folgenden Zeilen werden die \textsc{Html}-Darstellungen von Umlauten
      durch die entsprechenden Zeichen ersetzt.
\item Zeile 26 beginnt mit der Zustands-Spezifikation ``\texttt{header}''.  Daher ist
      diese Regel nur dann aktiv, wenn der Scanner in dem Zustand ``\texttt{header}'' ist.
      Diese Regel sucht nach dem schließenden Tag ``\texttt{</head>}''.  Wird dieses Tag
      gefunden, so wechselt der Scanner zurück in den Default-Zustand \texttt{YYINITIAL},
      in dem nur die Regeln verwendet werden, die nicht mit einem Zustand markiert sind.
\item Zeile 27 enthält ebenfalls eine Regel, die nur im Zustand ``\texttt{header}''
      ausgeführt wird.  Diese Regel liest ein beliebiges Zeichen, welches nicht weiter 
      verarbeitet wird und daher im Endeffekt verworfen wird.
\item Die Zeilen 29 und 30 enthalten entsprechende Regeln für den Zustand
      ``\texttt{script}''.
\end{enumerate}

\exercise
Einige Programmiersprachen unterstützen geschachtelte Kommentare.  Nehmen Sie an, dass Sie
für eine Programmiersprache, bei der Kommentare der Form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{/*} $\cdots$ \texttt{*/}
\\[0.2cm]
unterstützt werden, ein \textsl{JFlex}-Programm erstellen sollen, das diese Kommentare
aus einem gegebenen Programm entfernt. 
 Nehmen Sie dabei an, dass solche Kommentare geschachtelt werden dürfen.  
Nehmen Sie weiter an, dass die Programmiersprache auch Strings enthält, die durch doppelte
Anführungszeichen begrenzt werden.  Falls die
Zeichenfolgen ``\texttt{/*}'' und ``\texttt{*/}'' innerhalb eines Strings auftreten,
sollen diese Zeichenfolgen nicht als Begrenzung eines Kommentars gewertet werden.
\eox
\vspace*{0.3cm}

Die folgende Aufgabe dient der Verbesserung dieser Vorlesung.

\exercise
Überlegen Sie, bei welchen Software-Projekten sich \textsl{JFlex} überzeugend einsetzen lässt.
Wenn Sie ein schönes Beispiel finden, teilen Sie mir dies bitte per 
\href{mailto:karl.stroetmann@dhbw-mannheim.de}{Email} mit. \eox

%\exercise
%Try to parse the calendar entries of an ics-calendar file and do something with these entries...

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages.tex"
%%% End: 
