load("dfa-2-string.stlx");
load("minimize.stlx");

delta := procedure(q, c) {
    match ([q, c]) {
        case [0, "a"]: return 1;
        case [0, "b"]: return 6;
        case [1, "a"]: return 2;
        case [1, "b"]: return 7;
        case [2, "a"]: return 3;
        case [2, "b"]: return 6;
        case [3, "a"]: return 0;
        case [3, "b"]: return 7;
        case [4, "a"]: return 5;
        case [4, "b"]: return 2;
        case [5, "a"]: return 6;
        case [5, "b"]: return 8;
        case [6, "a"]: return 7;
        case [6, "b"]: return 2;
        case [7, "a"]: return 0;
        case [7, "b"]: return 3;
        case [8, "a"]: return 4;
        case [8, "b"]: return 8;
    }
};

contract := procedure(fa) {
    [states, sigma, delta, q0, final] := fa;
    newStates := { min(s) : s in states };
    newDelta := procedure(q, c) {
        return min(delta(arb({ m : m in states | q in m }), c));
    };
    newQ0 := min(q0);
    newFinal := { min(m) : m in final };
    return [newStates, sigma, newDelta, newQ0, newFinal];
};

prettyPrintFA := procedure(fa) {
    [states, sigma, delta, q0, final] := fa;
    print();
    print("set of states:       $states$");
    print("start state:         $q0$"    );
    print("transition function:" );
    for (p in states) {
        for (c in sigma) {
            print("$p$ |-\"$c$\"-> $delta(p, c)$");
        }
    }
    print("accepting states:    $final$" );
};

fa := [ [0..8], {"a", "b"}, delta, 0, {2,3,6,7} ];
dfa2dot(fa, "dfa-old");
fm := minimize(fa);
prettyPrintFA(fm);
fc := contract(fm);
print(fc);
dfa2dot(fc, "dfa");

